{"version":3,"file":"babylon.ktx2Decoder.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,wBAAyB,GAAIH,GACV,iBAAZC,QACdA,QAAQ,yBAA2BD,IAEnCD,EAAkB,YAAIC,GACvB,CATD,CASoB,oBAATK,KAAuBA,KAAyB,oBAAXC,OAAyBA,OAASC,MAAO,I,mBCRzF,IAAIC,EAAsB,CCA1BA,EAAwB,CAACP,EAASQ,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAEV,EAASS,IAC5EE,OAAOC,eAAeZ,EAASS,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,GCNDF,EAAoBQ,EAAI,WACvB,GAA0B,iBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOV,MAAQ,IAAIW,SAAS,cAAb,EAChB,CAAE,MAAOC,GACR,GAAsB,iBAAXC,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxBZ,EAAoBG,EAAI,CAACU,EAAKC,IAAUV,OAAOW,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFd,EAAoBkB,EAAKzB,IACH,oBAAX0B,QAA0BA,OAAOC,aAC1ChB,OAAOC,eAAeZ,EAAS0B,OAAOC,YAAa,CAAEC,MAAO,WAE7DjB,OAAOC,eAAeZ,EAAS,aAAc,CAAE4B,OAAO,GAAO,E,oCCLlDC,EAKAC,EAcAC,ECbAC,E,gXDNZ,SAAYH,GACR,qBACA,0BACH,CAHD,CAAYA,IAAAA,EAAmB,KAK/B,SAAYC,GACR,qCACA,2BACA,2BACA,yBACA,qCACA,mCACA,6BACA,2BACA,uBACA,eACA,iBACH,CAZD,CAAYA,IAAAA,EAAe,KAc3B,SAAYC,GACR,2EACA,uEACA,uEACA,yEACA,+EACA,6EACA,iEACA,uDACA,iEACA,qCACA,+BACA,gCACH,CAbD,CAAYA,IAAAA,EAAY,KEhBjB,MAAME,EAIEC,iBACP,OAAO5B,KAAK6B,eAChB,CAWAC,YAAYC,EAAuCH,EAAqBI,GAC/DD,EAA2BA,OAC5B/B,KAAKiC,UAAY,IAAIC,SAChBH,EAA2BA,OAC3BA,EAA2BH,YAAcA,GAAc,GACxDI,GAAeD,EAA2BC,YAG9ChC,KAAKiC,UAAY,IAAIC,SAASH,EAAuBH,GAAc,EAAGI,GAAeD,EAAuBC,YAGhHhC,KAAK6B,gBAAkB,CAC3B,CAMOM,YACH,MAAMb,EAAQtB,KAAKiC,UAAUG,SAASpC,KAAK6B,iBAE3C,OADA7B,KAAK6B,iBAAmB,EACjBP,CACX,CAMOe,WACH,MAAMf,EAAQtB,KAAKiC,UAAUK,QAAQtC,KAAK6B,iBAE1C,OADA7B,KAAK6B,iBAAmB,EACjBP,CACX,CAMOiB,aACH,MAAMjB,EAAQtB,KAAKiC,UAAUO,UAAUxC,KAAK6B,iBAAiB,GAE7D,OADA7B,KAAK6B,iBAAmB,EACjBP,CACX,CAMOmB,YACH,MAAMnB,EAAQtB,KAAKiC,UAAUS,SAAS1C,KAAK6B,iBAAiB,GAE5D,OADA7B,KAAK6B,iBAAmB,EACjBP,CACX,CAMOqB,aACH,MAAMrB,EAAQtB,KAAKiC,UAAUW,UAAU5C,KAAK6B,iBAAiB,GAE7D,OADA7B,KAAK6B,iBAAmB,EACjBP,CACX,CAMOuB,YACH,MAAMvB,EAAQtB,KAAKiC,UAAUa,SAAS9C,KAAK6B,iBAAiB,GAE5D,OADA7B,KAAK6B,iBAAmB,EACjBP,CACX,CAMOyB,aAEH,MAIMC,EAJOhD,KAAKiC,UAAUW,UAAU5C,KAAK6B,iBAAiB,GAIpC,GAAK,GAHf7B,KAAKiC,UAAUW,UAAU5C,KAAK6B,gBAAkB,GAAG,GAUjE,OADA7B,KAAK6B,iBAAmB,EACjBmB,CACX,CAOOC,eAAejB,GAClB,MAAMV,EAAQ,IAAI4B,WAAWlD,KAAKiC,UAAUF,OAAQ/B,KAAKiC,UAAUL,WAAa5B,KAAK6B,gBAAiBG,GAEtG,OADAhC,KAAK6B,iBAAmBG,EACjBV,CACX,CAOO6B,UAAUnB,GAEb,OADAhC,KAAK6B,iBAAmBG,EACjBhC,IACX,GD/HJ,SAAY0B,GACR,mBACA,yBACA,6BACA,kBACH,CALD,CAAYA,IAAAA,EAAsB,KAgH3B,MAAM0B,EAWTtB,YAAYuB,GACRrD,KAAKsD,MAAQD,CACjB,CAEWA,WACP,OAAOrD,KAAKsD,KAChB,CAEWC,aACP,OAAOvD,KAAKwD,OAChB,CAEWC,aACP,OAAOzD,KAAK0D,OAChB,CAEWC,eACP,OAAO3D,KAAK4D,SAChB,CAEWC,iCACP,OAAO7D,KAAK8D,2BAChB,CAEOC,UACH,OAAOX,EAAeY,QAAQhE,KAAKsD,MACvC,CAEOW,QACH,IAAIC,EAAe,GAKnB,MAAMC,EAAY,IAAIxC,EAAW3B,KAAKsD,MAAOY,EAAc,IAErDX,EAAUvD,KAAKwD,QAAU,CAC3BY,SAAUD,EAAUxB,aACpB0B,SAAUF,EAAUxB,aACpB2B,WAAYH,EAAUxB,aACtB4B,YAAaJ,EAAUxB,aACvB6B,WAAYL,EAAUxB,aACtB8B,WAAYN,EAAUxB,aACtB+B,UAAWP,EAAUxB,aACrBgC,WAAYR,EAAUxB,aACtBiC,uBAAwBT,EAAUxB,aAElCkC,cAAeV,EAAUxB,aACzBmC,cAAeX,EAAUxB,aACzBoC,cAAeZ,EAAUxB,aACzBqC,cAAeb,EAAUxB,aACzBsC,cAAed,EAAUpB,aACzBmC,cAAef,EAAUpB,cAG7B,GAAIQ,EAAOiB,WAAa,EACpB,MAAM,IAAIW,MAAM,yEAGpB,GAAI5B,EAAOkB,WAAa,EACpB,MAAM,IAAIU,MAAM,2EAGpB,GAAI5B,EAAOmB,UAAY,EACnB,MAAM,IAAIS,MAAM,0EAGpBjB,GAAgBC,EAAUvC,WAK1B,IAAI+C,EAAaS,KAAKC,IAAI,EAAG9B,EAAOoB,YAEpC,MAAMW,EAAc,IAAI3D,EAAW3B,KAAKsD,MAAOY,EAA2B,EAAbS,EAAiB,GAExElB,EAA8BzD,KAAK0D,QAAU,GAEnD,KAAOiB,KACHlB,EAAO8B,KAAK,CACR3D,WAAY0D,EAAYvC,aACxBf,WAAYsD,EAAYvC,aACxByC,uBAAwBF,EAAYvC,eAI5CmB,GAAgBoB,EAAY1D,WAK5B,MAAM6D,EAAY,IAAI9D,EAAW3B,KAAKsD,MAAOC,EAAOsB,cAAetB,EAAOuB,eAEpEnB,EAAY3D,KAAK4D,UAAY,CAC/B8B,SAAUD,EAAUtC,UAAU,GAAwBZ,aACtDoD,eAAgBF,EAAUlD,aAC1BqD,cAAeH,EAAUlD,aACzBsD,oBAAqBJ,EAAUlD,aAC/BuD,WAAYL,EAAUtD,YACtB4D,eAAgBN,EAAUtD,YAC1B6D,iBAAkBP,EAAUtD,YAC5B8D,MAAOR,EAAUtD,YACjB+D,oBAAqB,CACjBC,EAAGV,EAAUtD,YAAc,EAC3BiE,EAAGX,EAAUtD,YAAc,EAC3BkE,EAAGZ,EAAUtD,YAAc,EAC3BmE,EAAGb,EAAUtD,YAAc,GAE/BoE,WAAY,CACRd,EAAUtD,YACVsD,EAAUtD,YACVsD,EAAUtD,YACVsD,EAAUtD,YACVsD,EAAUtD,YACVsD,EAAUtD,YACVsD,EAAUtD,YACVsD,EAAUtD,aAEdqE,WAAY,EACZC,QAAS,IAAIC,OAGjB/C,EAAS6C,YAAc7C,EAASkC,oBAAsB,IAAM,GAE5D,IAAK,IAAIc,EAAI,EAAGA,EAAIhD,EAAS6C,WAAYG,IAAK,CAC1C,MAAMC,EAAS,CACXC,UAAWpB,EAAUlD,aACrBuE,UAAWrB,EAAUtD,YAAc,EACnC4E,YAAatB,EAAUtD,YACvB6E,aAAc,EACdC,eAAgB,CACZxB,EAAUtD,YACVsD,EAAUtD,YACVsD,EAAUtD,YACVsD,EAAUtD,aAEd+E,YAAazB,EAAU9C,aACvBwE,YAAa1B,EAAU9C,cAG3BiE,EAAOI,cAAqC,IAArBJ,EAAOG,cAAuB,EACrDH,EAAOG,YAAmC,GAArBH,EAAOG,YAE5BpD,EAAS8C,QAAQlB,KAAKqB,E,CAM1B,MAAMQ,EAAyCpH,KAAK8D,4BAA8B,CAAC,EAEnF,GAAIP,EAAO2B,cAAgB,EAAG,CAC1B,MAAMmC,EAAY,IAAI1F,EAAW3B,KAAKsD,MAAOC,EAAO0B,cAAe1B,EAAO2B,eAE1EkC,EAAIE,cAAgBD,EAAU9E,aAC9B6E,EAAIG,cAAgBF,EAAU9E,aAC9B6E,EAAII,oBAAsBH,EAAU1E,aACpCyE,EAAIK,oBAAsBJ,EAAU1E,aACpCyE,EAAIM,iBAAmBL,EAAU1E,aACjCyE,EAAIO,mBAAqBN,EAAU1E,aACnCyE,EAAIQ,WAAa,GAEjB,MAAMC,EAAa7H,KAAK8H,iBAExB,IAAK,IAAInB,EAAI,EAAGA,EAAIkB,EAAYlB,IAC5BS,EAAIQ,WAAWrC,KAAK,CAChBwC,WAAYV,EAAU1E,aACtBqF,mBAAoBX,EAAU1E,aAC9BsF,mBAAoBZ,EAAU1E,aAC9BuF,qBAAsBb,EAAU1E,aAChCwF,qBAAsBd,EAAU1E,eAIxC,MAAMyF,EAAsB7E,EAAO0B,cAAgBoC,EAAUzF,WACvDyG,EAAsBD,EAAsBhB,EAAII,oBAChDc,EAAmBD,EAAsBjB,EAAIK,oBAC7Cc,EAAqBD,EAAmBlB,EAAIM,iBAElDN,EAAIoB,cAAgB,IAAItF,WAAWlD,KAAKsD,MAAMvB,OAAQ/B,KAAKsD,MAAM1B,WAAawG,EAAqBhB,EAAII,qBACvGJ,EAAIqB,cAAgB,IAAIvF,WAAWlD,KAAKsD,MAAMvB,OAAQ/B,KAAKsD,MAAM1B,WAAayG,EAAqBjB,EAAIK,qBACvGL,EAAIsB,WAAa,IAAIxF,WAAWlD,KAAKsD,MAAMvB,OAAQ/B,KAAKsD,MAAM1B,WAAa0G,EAAkBlB,EAAIM,kBACjGN,EAAIuB,aAAe,IAAIzF,WAAWlD,KAAKsD,MAAMvB,OAAQ/B,KAAKsD,MAAM1B,WAAa2G,EAAoBnB,EAAIO,mB,CAE7G,CAEQG,iBACJ,IAAIc,EAAkBxD,KAAKC,IAAIrF,KAAKwD,QAAQgB,WAAY,GACxD,IAAK,IAAImC,EAAI,EAAGA,EAAI3G,KAAKwD,QAAQmB,WAAYgC,IACzCiC,GAAmBxD,KAAKC,IAAIrF,KAAKwD,QAAQgB,YAAcmC,EAAG,GAG9D,OAAOvB,KAAKC,IAAIrF,KAAKwD,QAAQiB,WAAY,GAAKzE,KAAKwD,QAAQkB,UAAYkE,CAC3E,CAEWC,oBACP,OAAqC,MAA9B7I,KAAK4D,UAAUkC,WAAgC,WAAoC,OAC9F,CAEWgD,eAGP,OAFgB9I,KAAK6I,eAGjB,KAAK,QACD,OACkC,IAA9B7I,KAAK4D,UAAU4C,aAC4B,KAA1CxG,KAAK4D,UAAU6C,QAAQ,GAAGM,aAAkF,KAA1C/G,KAAK4D,UAAU6C,QAAQ,GAAGM,aAGrG,KAAK,WACD,OAAiD,IAA1C/G,KAAK4D,UAAU6C,QAAQ,GAAGM,YAGzC,OAAO,CACX,CAEWgC,sBACP,OAAO/I,KAAKwD,QAAQoB,yBAA2BlD,EAAuBsH,SAC1E,CAEWC,qBACP,OAA2C,IAApCjJ,KAAK4D,UAAUoC,gBAC1B,CAEOkD,eAAe7F,GAClB,GAAIA,EAAKrB,YAAc,GAAI,CAEvB,MAAMmH,EAAa,IAAIjG,WAAWG,EAAKtB,OAAQsB,EAAKzB,WAAY,IAChE,GACsB,MAAlBuH,EAAW,IACO,KAAlBA,EAAW,IACO,KAAlBA,EAAW,IACO,KAAlBA,EAAW,IACO,KAAlBA,EAAW,IACO,KAAlBA,EAAW,IACO,KAAlBA,EAAW,IACO,MAAlBA,EAAW,IACO,KAAlBA,EAAW,IACO,KAAlBA,EAAW,IACQ,KAAnBA,EAAW,KACQ,KAAnBA,EAAW,IAEX,OAAO,C,CAIf,OAAO,CACX,EEnXG,MAAMC,EAMFF,gBAAgBG,GACnB,GAAIrJ,KAAKsJ,8BACL,OAAO,IAAIC,SAAQ,CAACC,EAASC,KACzBC,MAAML,GACDM,MAAMC,IACH,GAAIA,EAASC,GACT,OAAOD,EAASE,cAEpB,MAAM,IAAI3E,MAAM,4CAA4CkE,OAAUO,EAASG,YAAYH,EAASI,aAAa,IAEpHL,MAAMM,GAAeT,EAAQS,KAC7BC,OAAOC,IACJV,EAAOU,EAAO,GAChB,IAId,MAAMC,EAAKpK,KAAKqK,aAEhB,OAAO,IAAId,SAASC,IAChB,MAAMc,EAAqBC,IACC,eAApBA,EAAIlH,KAAKmH,QAA2BD,EAAIlH,KAAK+G,KAAOA,IACpDtK,KAAK2K,oBAAoB,UAAWH,GACpCd,EAAQe,EAAIlH,KAAK4G,Y,EAIzBnK,KAAK4K,iBAAiB,UAAWJ,GAEjCK,YAAY,CAAEH,OAAQ,WAAYnB,KAAMA,EAAMe,GAAIA,GAAK,GAE/D,CAQAtI,YAAY8I,EAA6BxB,EAAkByB,oBACvD7K,KAAK8K,UAAYF,EAEjB5K,KAAK+K,QAAU,IAAIC,YAAYC,OAAO,CAAEC,QAASlL,KAAK8K,YACtD9K,KAAKmL,sBAAwBnL,KAAK8K,WAAa,GAC/C9K,KAAKoL,kBAAoB,EACzBpL,KAAKqL,YAAc,IAAInI,WAAWlD,KAAK+K,QAAQhJ,OAAQ/B,KAAKoL,kBAAmBpL,KAAKmL,sBACxF,CAEWG,iBACP,OAAOtL,KAAK+K,OAChB,CAEOQ,cAAcC,EAAkBC,EAAiB,EAAGzJ,GAevD,OAdAA,EAAaA,GAAcwJ,GAAY,GAEnCxL,KAAK8K,UAAYU,GACjBxL,KAAK+K,QAAQW,KAAKF,EAAWxL,KAAK8K,WAClC9K,KAAK8K,UAAYU,EACjBxL,KAAKqL,YAAc,IAAInI,WAAWlD,KAAK+K,QAAQhJ,OAAQ0J,EAAQzJ,GAC/DhC,KAAKmL,sBAAwBnJ,EAC7BhC,KAAKoL,kBAAoBK,IAEzBzL,KAAKqL,YAAc,IAAInI,WAAWlD,KAAK+K,QAAQhJ,OAAQ0J,EAAQzJ,GAC/DhC,KAAKmL,sBAAwBnJ,EAC7BhC,KAAKoL,kBAAoBK,GAGtBzL,KAAKqL,WAChB,EAzEc,EAAA/B,+BAAgC,EAChC,EAAAuB,mBAAqB,GAEpB,EAAAR,WAAa,ECDzB,MAAMsB,EAGFzC,0BAA0B0C,GAC7BD,EAAkBE,aAAatG,KAAKqG,EACxC,CAMOE,eAAeC,EAA+BC,EAA2B/C,EAAyBgD,GACrG,IAAIL,EAAgC,KAEpC,MAAMzL,EAAM,EAAyB4L,GAAO,IAAM,EAAqBC,GAEvE,IAAK,IAAIrF,EAAI,EAAGA,EAAIgF,EAAkBE,aAAaK,SAAUvF,EACzD,GAAIgF,EAAkBE,aAAalF,GAAGwF,aAAaJ,EAAKC,EAAK/C,MAAqBgD,GAAUA,EAAOG,QAAQT,EAAkBE,aAAalF,GAAG0F,MAAQ,GAAI,CACrJT,EAAa5L,KAAKsM,uBAAuBnM,EAAKwL,EAAkBE,aAAalF,GAAG0F,MAC3ET,IACDA,EAAa,IAAID,EAAkBE,aAAalF,GAChDiF,EAAYW,aACRX,EAAYY,sBACPxM,KAAKyM,qBACNzM,KAAKyM,mBAAqB,IAAIrD,GAElCwC,EAAYc,iBAAiB1M,KAAKyM,qBAEjCd,EAAkBgB,qBAAqBxM,KACxCwL,EAAkBgB,qBAAqBxM,GAAO,IAElDwL,EAAkBgB,qBAAqBxM,GAAKoF,KAAKqG,IAErD,K,CAIR,OAAOA,CACX,CAEQU,uBAAuBnM,EAAayM,GACxC,MAAMC,EAAclB,EAAkBgB,qBAAqBxM,GAE3D,GAAI0M,EACA,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAYX,SAAUY,EAAG,CACzC,MAAMlB,EAAaiB,EAAYC,GAC/B,GAAIF,IAAmBhB,EAAWmB,UAC9B,OAAOnB,C,CAKnB,OAAO,IACX,EApDc,EAAAC,aAAyC,GAMxC,EAAAc,qBAA6D,CAAC,ECL1E,MAAMK,EACF9D,oBAAoB6C,EAA+BC,EAA2B/C,GACjF,OAAO,CACX,CAIO8D,UACH,OAAOC,EAAWX,IACtB,CAEOE,aAAoB,CAEpBC,oBACH,OAAO,CACX,CAEOE,iBAAiBO,GAAqC,CAEtDC,UACHnB,EACAC,EACAmB,EACAC,EACAC,EACA7H,EACA8H,EACAC,EACAC,GAEA,OAAOjE,QAAQC,QAAQ,KAC3B,EA1Bc,EAAA6C,KAAO,aCNlB,MAAMoB,UAAuBT,EAMtBU,cACN,OAAI1N,KAAK2N,iBAIT3N,KAAK2N,eAAiBvE,EAAkBwE,SAAS5N,KAAK6N,aAAalE,MAAMM,GAC9D,IAAIV,SAASC,IAChBwB,YAAY8C,YAAY7D,EAA2B,CAAE8D,IAAK,CAAEC,OAAQhO,KAAKiO,eAAe3C,cAAgB3B,MAAMuE,IAC1G1E,EAAQ,CAAE7J,OAAQuO,EAAcC,SAASzO,SAAU,GACrD,OAPCM,KAAK2N,cAYpB,CAGcS,oBACV,OAAOpO,KAAKiO,cAChB,CAGUI,cAAcC,GACpBtO,KAAK6N,YAAcS,CACvB,CAEO/B,aACHvM,KAAKuO,mBAAoB,CAC7B,CAEO/B,oBACH,OAAO,CACX,CAEOE,iBAAiBO,GACpBjN,KAAKiO,eAAiBhB,CAC1B,CAEOC,UACHnB,EACAC,EACAmB,EACAC,EACAC,EACA7H,EACA8H,EACAC,EACAC,GAEA,OAAOxN,KAAK0N,cAAc/D,MAAMuE,IAC5B,MAAMtC,EAAkBsC,EAAcvO,QAC/B6O,EAAaC,EAAyBC,GAAW1O,KAAK2O,oBAAoBvB,EAAOC,EAAQ7H,EAAwBgI,GAExH,OAAyC,IAAlC5B,EAAWsB,UAAUwB,GAAkB1O,KAAKuO,kBAAoBC,EAAYI,QAAUH,EAAyBG,QAAW,IAAI,GAE7I,CAEUD,oBACNvB,EACAC,EACA7H,EACAgI,EACAqB,GAEA,MAAMH,GAAYtB,EAAQ,GAAM,IAAOC,EAAS,GAAM,QAEpByB,IAA9BD,IACArJ,EAAyB4H,GAAUC,EAAS,GAAM,GAAK,EAAIwB,GAG/D,MAAME,EAA0G,GAA7E,GAAVL,EAAe,OAAS1O,KAAKuO,kBAAoB,EAAI/I,IAA4B,IAEpGgJ,EAAcxO,KAAKoO,cAAc7C,cAAcwD,EAAgB,MAAiB,GAAVL,GAEtED,EAA0BzO,KAAKuO,kBAC/B,KACA,IAAIrL,WACAlD,KAAKiO,eAAe3C,WAAWvJ,OAC/B,MAAkB,GAAV2M,OACsBI,IAA9BD,EAA0CzB,EAAQC,EAASwB,EAA4BrJ,GAKjG,OAFAgJ,EAAYQ,IAAIxB,GAET,CAACgB,EAAaC,EAAyBC,EAClD,EC5FG,MAAMO,UAAkCxB,EAOpCvE,oBAAoB6C,EAA+BC,EAA2B/C,GACjF,OAAO8C,IAAQ,YAAqCC,IAAQ,eAChE,CAIOe,UACH,OAAOkC,EAA0B5C,IACrC,CAEOE,aACH2C,MAAM3C,aACNvM,KAAKqO,cAAcY,EAA0BE,cACjD,EAhBc,EAAAA,cAAgB,kEAOhB,EAAA9C,KAAO,iCCXlB,MAAM+C,UAAiC3B,EAOnCvE,oBAAoB6C,EAA+BC,EAA2B/C,GACjF,OAAO8C,IAAQ,YAAqCC,IAAQ,UAChE,CAIOe,UACH,OAAOqC,EAAyB/C,IACpC,CAEOE,aACH2C,MAAM3C,aACNvM,KAAKqO,cAAce,EAAyBD,cAChD,EAhBc,EAAAA,cAAgB,iEAOhB,EAAA9C,KAAO,gCCVlB,MAAMgD,UAAwC5B,EAM1CvE,oBAAoB6C,EAA+BC,EAA2B/C,GACjF,OAAO8C,IAAQ,YAAqCC,IAAQ,WAAgC/C,CAChG,CAIO8D,UACH,OAAOsC,EAAgChD,IAC3C,CAEOE,aACH2C,MAAM3C,aACNvM,KAAKuO,mBAAoB,EACzBvO,KAAKqO,cAAcgB,EAAgCF,cACvD,CAEOjC,UACHnB,EACAC,EACAmB,EACAC,EACAC,EACA7H,EACA8H,EACAC,EACAC,GAEA,OAAOxN,KAAK0N,cAAc/D,MAAMuE,IAC5B,MAAMtC,EAAkBsC,EAAcvO,QAC/B,CAAE8O,GAA2BzO,KAAK2O,oBAAoBvB,EAAOC,EAAQ7H,EAAwBgI,EAAa,GAEjH,OAA4C,IAArC5B,EAAW0D,OAAOlC,EAAOC,GAAgBoB,EAAyBG,QAAU,IAAI,GAE/F,EAnCc,EAAAO,cAAgB,4EAMhB,EAAA9C,KAAO,uCCVlB,MAAMkD,UAAuC9B,EAMzCvE,oBAAoB6C,EAA+BC,EAA2B/C,GACjF,OAAO8C,IAAQ,YAAqCC,IAAQ,UAA+B/C,CAC/F,CAIO8D,UACH,OAAOwC,EAA+BlD,IAC1C,CAEOE,aACH2C,MAAM3C,aACNvM,KAAKuO,mBAAoB,EACzBvO,KAAKqO,cAAckB,EAA+BJ,cACtD,CAEOjC,UACHnB,EACAC,EACAmB,EACAC,EACAC,EACA7H,EACA8H,EACAC,EACAC,GAEA,OAAOxN,KAAK0N,cAAc/D,MAAMuE,IAC5B,MAAMtC,EAAkBsC,EAAcvO,QAC/B,CAAE8O,GAA2BzO,KAAK2O,oBAAoBvB,EAAOC,EAAQ7H,EAAwBgI,EAAa,GAEjH,OAA4C,IAArC5B,EAAW0D,OAAOlC,EAAOC,GAAgBoB,EAAyBG,QAAU,IAAI,GAE/F,EAnCc,EAAAO,cAAgB,2EAMhB,EAAA9C,KAAO,sCCVlB,MAAMmD,UAAsC/B,EAMxCvE,oBAAoB6C,EAA+BC,EAA2B/C,GACjF,OAAO8C,IAAQ,YAAqCC,IAAQ,IAChE,CAIOe,UACH,OAAOyC,EAA8BnD,IACzC,CAEOE,aACH2C,MAAM3C,aACNvM,KAAKuO,mBAAoB,EACzBvO,KAAKqO,cAAcmB,EAA8BL,cACrD,CAEOjC,UACHnB,EACAC,EACAmB,EACAC,EACAC,EACA7H,EACA8H,EACAC,EACAC,GAEA,OAAOxN,KAAK0N,cAAc/D,MAAMuE,IAC5B,MAAMtC,EAAkBsC,EAAcvO,QAC/B,CAAE8O,GAA2BzO,KAAK2O,oBAAoBvB,EAAOC,EAAQ7H,EAAwBgI,EAAa,GAEjH,OAA4C,IAArC5B,EAAW0D,OAAOlC,EAAOC,GAAgBoB,EAAyBG,QAAU,IAAI,GAE/F,EAnCc,EAAAO,cAAgB,sDAMhB,EAAA9C,KAAO,qCCVlB,MAAMoD,UAAuChC,EAMzCvE,oBAAoB6C,EAA+BC,EAA2B/C,GACjF,OAAO8C,IAAQ,YAAqCC,IAAQ,KAChE,CAIOe,UACH,OAAO0C,EAA+BpD,IAC1C,CAEOE,aACH2C,MAAM3C,aACNvM,KAAKuO,mBAAoB,EACzBvO,KAAKqO,cAAcoB,EAA+BN,cACtD,CAEOjC,UACHnB,EACAC,EACAmB,EACAC,EACAC,EACA7H,EACA8H,EACAC,EACAC,GAEA,OAAOxN,KAAK0N,cAAc/D,MAAMuE,IAC5B,MAAMtC,EAAkBsC,EAAcvO,QAC/B,CAAE8O,GAA2BzO,KAAK2O,oBAAoBvB,EAAOC,EAAQ7H,EAAwBgI,EAAa,GAEjH,OAA4C,IAArC5B,EAAW0D,OAAOlC,EAAOC,GAAgBoB,EAAyBG,QAAU,IAAI,GAE/F,EAnCc,EAAAO,cAAgB,uEAMhB,EAAA9C,KAAO,sCCNlB,MAAMqD,UAAsB1C,EAcxBD,UACH,OAAO2C,EAAcrD,IACzB,CAKQsD,yBACJ,OAAI3P,KAAK4P,6BAIT5P,KAAK4P,2BAA6BxG,EAAkBwE,SAAS8B,EAAcP,eAAexF,MAAMM,IAC5F,GAAIyF,EAAcG,oBACdC,cAAcJ,EAAcK,kBAG3B,GAA8B,oBAAnBC,eACZ,OAAO,IAAIzG,SAAQ,CAACC,EAASC,KACzB,MAAMwG,EAAOC,SAASC,qBAAqB,QAAQ,GAC7CC,EAASF,SAASG,cAAc,UACtCD,EAAOE,aAAa,OAAQ,mBAC5BF,EAAOE,aAAa,MAAOZ,EAAcK,aAEzCK,EAAOG,OAAS,KACZP,eAAe,CAAE/F,eAAcN,MAAM6G,IACjCA,EAAYC,kBACZzQ,KAAK0Q,gBAAkBF,EACvBhH,GAAS,GACX,EAGN4G,EAAOO,QAAU,KACblH,EAAO,sCAAsC,EAGjDwG,EAAKW,YAAYR,EAAO,IAIhC,OAAO,IAAI7G,SAASC,IAChBwG,eAAe,CAAE/F,eAAcN,MAAM6G,IACjCA,EAAYC,kBACZzQ,KAAK0Q,gBAAkBF,EACvBhH,GAAS,GACX,GACJ,KArCKxJ,KAAK4P,0BAyCpB,CAGO1G,oBAAoB6C,EAA+BC,EAA2B/C,GACjF,OAAO,CACX,CAEOiE,UACHnB,EACAC,EACAmB,EACAC,EACAC,EACA7H,EACA8H,EACAC,EACAC,GAIA,OAAOxN,KAAK2P,yBAAyBhG,MAAK,KACtC,MAAM6G,EAAcxQ,KAAK0Q,gBAEzB,IAAI9E,EACAiF,EACAC,EACAC,EAAmB,KAEvB,IACInF,EAAaG,IAAQ,WAAoC,IAAIyE,EAAYQ,qBAAyB,IAAIR,EAAYS,4BAClH,MAAMC,EAAYnF,IAAQ,WAAoCyE,EAAYW,cAAcC,SAAWZ,EAAYW,cAAcE,MAE7HR,EAAY,IAAIL,EAAYc,UAAUJ,EAAW9D,EAAOC,EAAQF,GAEhE,MAAMoE,EAAef,EAAYhP,gBAAgB,EAAqBwK,IAEtE,IAAKwE,EAAYgB,kBAAkBD,EAAcL,GAC7C,MAAM,IAAI/L,MACN,oCAAoC,EAAyB4G,WAAa,EAAqBC,kDAIvG,GAAID,IAAQ,QAAgC,CACxC,MAAM3E,EAAMkG,EAAWzJ,2BAEvB+H,EAAW6F,eAAerK,EAAIE,cAAeF,EAAIoB,cAAepB,EAAIG,cAAeH,EAAIqB,eACvFmD,EAAW8F,aAAatK,EAAIsB,YAE5BmI,EAAU5K,MAAQsH,EAAWxF,WAC7B8I,EAAUc,cAAgB,EAC1Bd,EAAUe,cAAgBrE,EAAWtF,mBACrC4I,EAAUgB,gBAAkBtE,EAAWrF,qBAAuB,EAAIqF,EAAWtF,mBAAqB,EAClG4I,EAAUiB,gBAAkBvE,EAAWpF,qBAEvC2I,EAASlF,EAAWmG,eAAeR,EAAc/D,EAAaqD,EAAW,GApCrE,E,MAsCJA,EAAU5K,MAAQ,EAClB4K,EAAUc,cAAgB,EAC1Bd,EAAUe,cAAgBpM,EAC1BqL,EAAUgB,gBAAkB,EAC5BhB,EAAUiB,gBAAkB,EAE5BhB,EAASlF,EAAWmG,eAAeR,EAAc/D,EAAaqD,EAAW,EAAGvD,EAAWxE,UA5CnF,E,SA+CJ8C,GACAA,EAAWoG,SAGXnB,GACAA,EAAUmB,SAGVlB,GAAUA,EAAOmB,kBACjBlB,EAAcD,EAAOmB,gBAAgBC,wBAAwBtD,QAC7DkC,EAAOmB,gBAAgBD,S,CAI/B,OAAOjB,CAAW,GAE1B,ECjJJ,IAAIoB,EACAhE,EACAiE,EDEc,EAAArC,YAAc,0EAId,EAAAZ,cAAgB,4EAEhB,EAAAU,qBAAsB,EAEtB,EAAAxD,KAAO,gBCRzB,MAAMgG,EAAgB,CAClBtE,IAAK,CACDuE,gCAAiC,WAC7BF,EAAO,IAAIlP,WAAWiL,EAASzO,QAAQsO,OAAOjM,OAClD,IAOD,MAAMwQ,EAGTJ,OACI,OAAIA,IAOAA,EAHiB,oBAAVzI,MAGAA,MAAM6I,EAAYpD,eACpBxF,MAAMC,IACH,GAAIA,EAASC,GACT,OAAOD,EAASE,cAEpB,MAAM,IAAI3E,MAAM,2EAA2EyE,EAASG,YAAYH,EAASI,aAAa,IAEzIL,MAAMG,GAAgBkB,YAAY8C,YAAYhE,EAAauI,KAC3D1I,KAAK3J,KAAKwS,OAIRxH,YAAYyH,qBAAqB/I,MAAM6I,EAAYpD,eAAgBkD,GAAe1I,KAAK3J,KAAKwS,OAGhGL,EACX,CAEAK,MAAM1B,GACF3C,EAAW2C,EAAO3C,SAElBkE,EAActE,IAAIuE,iCACtB,CAEAhD,OAAOoD,EAAmBC,EAAmB,GACzC,IAAKxE,EACD,MAAM,IAAIhJ,MAAM,+CAIpB,MAAMyN,EAAiBF,EAAM1Q,WACvB6Q,EAAgB1E,EAASzO,QAAQoT,OAAOF,GAC9CR,EAAKpD,IAAI0D,EAAOG,GAGhBF,EAAmBA,GAAoBI,OAAO5E,EAASzO,QAAQsT,0BAA0BH,EAAeD,IACxG,MAAMK,EAAkB9E,EAASzO,QAAQoT,OAAOH,GAC1CO,EAAa/E,EAASzO,QAAQyT,gBAAgBF,EAAiBN,EAAkBE,EAAeD,GAGhGQ,EAAMhB,EAAKxD,MAAMqE,EAAiBA,EAAkBC,GAI1D,OAHA/E,EAASzO,QAAQ2T,KAAKR,GACtB1E,EAASzO,QAAQ2T,KAAKJ,GAEfG,CACX,EAvDc,EAAAjE,cAAgB,6CC1BlC,MAAMmE,EAAmC,CACrCjC,MAAO,CACHkC,OAAQ,YACRC,IAAK,CACDC,gBAAiB,SACjBC,aAAc,cACdC,kBAAkB,GAEtBC,GAAI,CACAC,IAAK,OACLL,IAAK,CACDM,OAAO,EACPN,IAAK,CACDC,gBAAiB,YACjBC,aAAc,6BAElBE,GAAI,CACAH,gBAAiB,WACjBC,aAAc,yBAGtBE,GAAI,CACAC,IAAK,OACLC,OAAO,EACPN,IAAK,CACDC,gBAAiB,WACjBC,aAAc,6BAElBE,GAAI,CACAC,IAAK,OACLL,IAAK,CACDC,gBAAiB,WACjBC,aAAc,kCAElBE,GAAI,CACAC,IAAK,OACLL,IAAK,CACDM,OAAO,EACPN,IAAK,CACDC,gBAAiB,WACjBC,aAAc,iCAElBE,GAAI,CACAH,gBAAiB,UACjBC,aAAc,iCAGtBE,GAAI,CACAC,IAAK,QACLE,iBAAiB,EACjBP,IAAK,CACDM,OAAO,EACPN,IAAK,CACDC,gBAAiB,gBACjBC,aAAc,oCAElBE,GAAI,CACAH,gBAAiB,eACjBC,aAAc,oCAGtBE,GAAI,CACAH,gBAAiB,SACjBC,aAAc,cACdC,kBAAkB,SAS9CK,MAAO,CACHT,OAAQ,YACRC,IAAK,CACDC,gBAAiB,SACjBC,aAAc,cACdC,kBAAkB,GAEtBC,GAAI,CACAL,OAAQ,UACRC,IAAK,CACDC,gBAAiB,KACjBC,aAAc,WACdC,kBAAkB,GAEtBC,GAAI,CACAL,OAAQ,WACRC,IAAK,CACDC,gBAAiB,MACjBC,aAAc,YACdC,kBAAkB,GAEtBC,GAAI,CACAC,IAAK,OACLL,IAAK,CACDC,gBAAiB,gBACjBC,aAAc,gCAElBE,GAAI,CACAC,IAAK,OACLL,IAAK,CACDC,gBAAiB,WACjBC,aAAc,kCAElBE,GAAI,CACAL,OAAQ,wCACRC,IAAK,CACDC,gBAAiB,SACjBC,aAAc,cACdC,kBAAkB,GAEtBC,GAAI,CACAC,IAAK,OACLL,IAAK,CACDM,OAAO,EACPN,IAAK,CACDC,gBAAiB,YACjBC,aAAc,6BAElBE,GAAI,CACAH,gBAAiB,WACjBC,aAAc,yBAGtBE,GAAI,CACAC,IAAK,OACLL,IAAK,CACDC,gBAAiB,WACjBC,aAAc,6BAElBE,GAAI,CACAC,IAAK,OACLL,IAAK,CACDM,OAAO,EACPN,IAAK,CACDC,gBAAiB,WACjBC,aAAc,iCAElBE,GAAI,CACAH,gBAAiB,UACjBC,aAAc,iCAGtBE,GAAI,CACAC,IAAK,QACLE,iBAAiB,EACjBP,IAAK,CACDM,OAAO,EACPN,IAAK,CACDC,gBAAiB,gBACjBC,aAAc,oCAElBE,GAAI,CACAH,gBAAiB,eACjBC,aAAc,oCAGtBE,GAAI,CACAH,gBAAiB,SACjBC,aAAc,cACdC,kBAAkB,cAc3D,MAAMM,EACD/K,mBAAmBgL,GACvB,YAA6CpF,IAArCoF,EAAoBR,YAChC,CAWWD,sBACP,OAAOzT,KAAKmU,gBAChB,CAEWT,mBACP,OAAO1T,KAAKoU,aAChB,CAEWT,uBACP,OAAO3T,KAAKqU,iBAChB,CAEAvS,YAAY+G,EAAyCC,EAAmBwL,EAAuBC,EAA0CC,GACrIxU,KAAKyU,eAAiB5L,EACtB7I,KAAK0U,UAAY5L,EACjB9I,KAAK2U,cAAgBL,EACrBtU,KAAK4U,MAAQL,EACbvU,KAAK6U,SAAWL,GAAW,CAAC,EAE5BxU,KAAK8U,UAAUxB,EACnB,CAEOwB,UAAUC,GACb,MAAMb,EAAOlU,KAAKyU,iBAAmB,WAAoCM,EAAKf,MAAQe,EAAK1D,MAI3F,OAHI6C,GACAlU,KAAKgV,WAAWd,QAEJpF,IAAToF,CACX,CAEQc,WAAWd,GACf,GAAKA,EAIL,GAAID,EAAsBgB,YAAYf,GAClClU,KAAKmU,iBAAmBD,EAAKT,gBAC7BzT,KAAKoU,cAAgBF,EAAKR,aAC1B1T,KAAKqU,kBAAoBH,EAAKP,mBAAoB,MAC/C,CACH,IAAIuB,GAAY,OAECpG,IAAboF,EAAKL,MACLqB,EAAYA,KAAelV,KAAK4U,MAAMV,EAAKL,WAE3B/E,IAAhBoF,EAAKX,SACL2B,EAAYA,KAAelV,KAAK6U,SAASX,EAAKX,cAE/BzE,IAAfoF,EAAKJ,QACLoB,EAAYA,GAAalV,KAAK0U,YAAcR,EAAKJ,YAExBhF,IAAzBoF,EAAKH,kBACLmB,EAAYA,GAAalV,KAAK2U,gBAAkBT,EAAKH,sBAE5BjF,IAAzBoF,EAAKT,kBAEDyB,EADAxO,MAAMyO,QAAQjB,EAAKT,iBACPyB,IAAsE,IAAzDhB,EAAKT,gBAAgBrH,QAAQpM,KAAKmU,kBAE/Ce,GAAahB,EAAKT,kBAAoBzT,KAAKmU,kBAI/DnU,KAAKgV,WAAWE,EAAYhB,EAAKV,IAAOU,EAAKN,G,CAErD,ECzOJ,MAAMU,EAAgBhT,GACe,IAAzBA,EAASA,EAAQ,IAAuB,IAAVA,EAOnC,MAAM8T,EAMTtT,cACI9B,KAAKqV,eAAiB,IAAI1J,CAC9B,CAEO2D,OAAOjM,EAAkBkR,EAA0CC,GACtE,MAAMc,EAAe,IAAKd,KAAYY,EAAYG,uBAElD,OAAOhM,QAAQC,UAAUG,MAAK,KAC1B,MAAM6L,EAAM,IAAIpS,EAAeC,GAE/B,IAAKmS,EAAIzR,UACL,MAAM,IAAIoB,MAAM,qCAKpB,OAFAqQ,EAAIvR,QAEAuR,EAAIzM,iBACC/I,KAAKyV,eACNzV,KAAKyV,aAAe,IAAIlD,GAGrBvS,KAAKyV,aAAatD,OAAOxI,MAAK,IAC1B3J,KAAK0V,YAAYF,EAAKjB,EAAMe,MAIpCtV,KAAK0V,YAAYF,EAAKjB,EAAMe,EAAa,GAExD,CAEQI,YAAYF,EAAqBjB,EAA0CC,GAC/E,MAAMpH,EAAQoI,EAAIjS,OAAOe,WACnB+I,EAASmI,EAAIjS,OAAOgB,YACpBoR,EAAeH,EAAI3M,cAEnB+M,EAAe,IAAI3B,EAAsB0B,EAAcH,EAAI1M,SAAUwL,EAAalH,IAAUkH,EAAajH,GAASkH,EAAMC,GAE1HA,GAASqB,6BACTD,EAAad,UAAUN,GAASqB,6BAGpC,MAAMpC,EAAkBmC,EAAanC,gBAC/BC,EAAekC,EAAalC,aAC5BC,EAAmBiC,EAAajC,iBAEhC/H,EAAa5L,KAAKqV,eAAevJ,eAAe6J,EAAclC,EAAiB+B,EAAIvM,eAAgBuL,GAASsB,mBAElH,GAAmB,OAAflK,EACA,MAAM,IAAIzG,MACN,2DAA2D,EAAyBwQ,kBAA6B,EAAqBlC,OAI9I,MAAMsC,EAA+B,GAC/BC,EAAkD,GAClDC,EAAiC,CACnC7I,MAAO,EACPC,OAAQ,EACR6I,iBAAkBxC,EAClBqC,UACA9M,eAAgBuM,EAAIvM,eACpBH,SAAU0M,EAAI1M,SACd8D,eAAgBhB,EAAWmB,WAG/B,IAAIoJ,EAAsB,EAE1B,IAAK,IAAIhJ,EAAQ,EAAGA,EAAQqI,EAAIjS,OAAOoB,WAAYwI,IAAS,CACpDA,EAAQ,IACRgJ,GAAuB/Q,KAAKC,IAAImQ,EAAIjS,OAAOkB,WAAY,GAAK+Q,EAAIjS,OAAOmB,UAAYU,KAAKC,IAAImQ,EAAIjS,OAAOiB,YAAe2I,EAAQ,EAAI,IAGtI,MAAMiJ,EAAahR,KAAKiR,MAAMjJ,GAAS,GAAKD,KAAW,EACjDmJ,EAAclR,KAAKiR,MAAMhJ,GAAU,GAAKF,KAAW,EAEnDoJ,EAAmBf,EAAIjS,OAAOmB,UAC9B8R,GAAyBJ,EAAa,GAAM,IAAOE,EAAc,GAAM,GAAKd,EAAI7R,SAAS4C,WAAW,GAEpGkQ,EAA8BjB,EAAI/R,OAAO0J,GAAO3H,uBAEtD,IAAIkR,EAAkBlB,EAAInS,KAAKtB,OAE3B4U,EAAkBnB,EAAI/R,OAAO0J,GAAOvL,WAAa4T,EAAInS,KAAKzB,WAC1DgV,EAAqB,EAErBpB,EAAIjS,OAAOqB,yBAA2BlD,EAAuBsH,YAC7D0N,EAAkB1W,KAAKyV,aAAanG,OAAO,IAAIpM,WAAWwT,EAAiBC,EAAiBnB,EAAI/R,OAAO0J,GAAOnL,YAAayU,GAC3HE,EAAkB,GAGR,IAAVxJ,IACA8I,EAAY7I,MAAQuG,EAAoByC,EAAa,GAAK,EAAKA,EAC/DH,EAAY5I,OAASsG,EAAoB2C,EAAc,GAAK,EAAKA,GAGrE,IAAK,IAAIO,EAAa,EAAGA,EAAaN,EAAkBM,IAAc,CAClE,IAAIrJ,EACAD,EAAoC,KAEpCiI,EAAIjS,OAAOqB,yBAA2BlD,EAAuBoV,SAC7DvJ,EAAYiI,EAAI3R,2BAA2B+D,WAAYuO,EAAsBU,GAE7ErJ,EAAc,IAAItK,WAAWwT,EAAiBC,EAAkBpJ,EAAUvF,mBAAoBuF,EAAUtF,mBAAqBsF,EAAUpF,wBAEvIqF,EAAc,IAAItK,WAAWwT,EAAiBC,EAAkBC,EAAoBJ,GAEpFI,GAAsBJ,GAG1B,MAAMO,EAAuB,CACzB1T,KAAM,KACN+J,MAAOgJ,EACP/I,OAAQiJ,GAGNU,EAAiBpL,EAClBsB,UAAUyI,EAAclC,EAAiBtG,EAAOiJ,EAAYE,EAAaG,EAA6BjB,EAAKjI,EAAWC,GACtH7D,MAAMtG,IACH0T,EAAO1T,KAAOA,EACPA,KAEV6G,OAAOC,IACJ8L,EAAYgB,OAAShB,EAAYgB,QAAU,GAC3ChB,EAAYgB,QAAU9M,EAAS,KAAOA,EAAO+M,MAAQ,KAC9C,QAGflB,EAAazQ,KAAKyR,GAElBjB,EAAQxQ,KAAKwR,E,EAIrB,OAAOxN,QAAQ4N,IAAInB,GAAcrM,MAAK,IAC3BsM,GAEf,EA1Ic,EAAAV,sBAAkD,CAAC,EA8IrE5J,EAAkByL,mBAAmBnI,GACrCtD,EAAkByL,mBAAmBhI,GACrCzD,EAAkByL,mBAAmB/H,GACrC1D,EAAkByL,mBAAmB7H,GACrC5D,EAAkByL,mBAAmB5H,GACrC7D,EAAkByL,mBAAmB3H,GACrC9D,EAAkByL,mBAAmB1H,GCrLrC,MAAM2H,OAAiC,IAAX,EAAA5W,EAAyB,EAAAA,EAA2B,oBAAXI,OAAyBA,YAASiO,OAC3E,IAAjBuI,IACDA,EAAcC,YAAclC,GCFtC,U","sources":["webpack://KTX2DECODER/webpack/universalModuleDefinition","webpack://KTX2DECODER/webpack/bootstrap","webpack://KTX2DECODER/webpack/runtime/define property getters","webpack://KTX2DECODER/webpack/runtime/global","webpack://KTX2DECODER/webpack/runtime/hasOwnProperty shorthand","webpack://KTX2DECODER/webpack/runtime/make namespace object","webpack://KTX2DECODER/../../../dev/core/src/Materials/Textures/ktx2decoderTypes.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/ktx2FileReader.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/Misc/dataReader.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/wasmMemoryManager.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/transcoderManager.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/transcoder.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/Transcoders/liteTranscoder.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/Transcoders/liteTranscoder_UASTC_ASTC.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/Transcoders/liteTranscoder_UASTC_BC7.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/Transcoders/liteTranscoder_UASTC_RGBA_UNORM.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/Transcoders/liteTranscoder_UASTC_RGBA_SRGB.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/Transcoders/liteTranscoder_UASTC_R8_UNORM.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/Transcoders/liteTranscoder_UASTC_RG8_UNORM.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/Transcoders/mscTranscoder.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/zstddec.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/transcodeDecisionTree.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/ktx2Decoder.ts","webpack://KTX2DECODER/../../../tools/ktx2Decoder/src/legacy/legacy.ts","webpack://KTX2DECODER/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-ktx2decoder\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-ktx2decoder\"] = factory();\n\telse\n\t\troot[\"KTX2DECODER\"] = factory();\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export enum SourceTextureFormat {\r\n    ETC1S,\r\n    UASTC4x4,\r\n}\r\n\r\nexport enum TranscodeTarget {\r\n    ASTC_4X4_RGBA,\r\n    BC7_RGBA,\r\n    BC3_RGBA,\r\n    BC1_RGB,\r\n    PVRTC1_4_RGBA,\r\n    PVRTC1_4_RGB,\r\n    ETC2_RGBA,\r\n    ETC1_RGB,\r\n    RGBA32,\r\n    R8,\r\n    RG8,\r\n}\r\n\r\nexport enum EngineFormat {\r\n    COMPRESSED_RGBA_BPTC_UNORM_EXT = 0x8e8c,\r\n    COMPRESSED_RGBA_ASTC_4X4_KHR = 0x93b0,\r\n    COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83f0,\r\n    COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83f3,\r\n    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8c02,\r\n    COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8c00,\r\n    COMPRESSED_RGBA8_ETC2_EAC = 0x9278,\r\n    COMPRESSED_RGB8_ETC2 = 0x9274,\r\n    COMPRESSED_RGB_ETC1_WEBGL = 0x8d64,\r\n    RGBA8Format = 0x8058,\r\n    R8Format = 0x8229,\r\n    RG8Format = 0x822b,\r\n}\r\n\r\n/**\r\n * Leaf node of a decision tree\r\n * It defines the transcoding format to use to transcode the texture as well as the corresponding format to use at the engine level when creating the texture\r\n */\r\nexport interface ILeaf {\r\n    /**\r\n     * The format to transcode to\r\n     */\r\n    transcodeFormat: TranscodeTarget;\r\n\r\n    /**\r\n     * The format to use when creating the texture at the engine level after it has been transcoded to transcodeFormat\r\n     */\r\n    engineFormat: EngineFormat;\r\n\r\n    /**\r\n     * Whether the texture must be rounded to a multiple of 4 (should normally be the case for all compressed formats). Default: true\r\n     */\r\n    roundToMultiple4?: boolean;\r\n}\r\n\r\n/**\r\n * Regular node of a decision tree\r\n *\r\n * Each property (except for \"yes\" and \"no\"), if not empty, will be checked in order to determine the next node to select.\r\n * If all checks are successful, the \"yes\" node will be selected, else the \"no\" node will be selected.\r\n */\r\nexport interface INode {\r\n    /**\r\n     * The name of the capability to check. Can be one of the following:\r\n     *      astc\r\n     *      bptc\r\n     *      s3tc\r\n     *      pvrtc\r\n     *      etc2\r\n     *      etc1\r\n     */\r\n    cap?: string;\r\n\r\n    /**\r\n     * The name of the option to check from the options object passed to the KTX2 decode function. {@link IKTX2DecoderOptions}\r\n     */\r\n    option?: string;\r\n\r\n    /**\r\n     * Checks if alpha is present in the texture\r\n     */\r\n    alpha?: boolean;\r\n\r\n    /**\r\n     * Checks the currently selected transcoding format.\r\n     */\r\n    transcodeFormat?: TranscodeTarget | TranscodeTarget[];\r\n\r\n    /**\r\n     * Checks that the texture is a power of two\r\n     */\r\n    needsPowerOfTwo?: boolean;\r\n\r\n    /**\r\n     * The node to select if all checks are successful\r\n     */\r\n    yes?: INode | ILeaf;\r\n\r\n    /**\r\n     * The node to select if at least one check is not successful\r\n     */\r\n    no?: INode | ILeaf;\r\n}\r\n\r\n/**\r\n * Decision tree used to determine the transcoding format to use for a given source texture format\r\n */\r\nexport interface IDecisionTree {\r\n    /**\r\n     * textureFormat can be either UASTC or ETC1S\r\n     */\r\n    [textureFormat: string]: INode;\r\n}\r\n\r\n/**\r\n * Result of the KTX2 decode function\r\n */\r\nexport interface IDecodedData {\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Height of the texture\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The format to use when creating the texture at the engine level\r\n     * This corresponds to the engineFormat property of the leaf node of the decision tree\r\n     */\r\n    transcodedFormat: number;\r\n\r\n    /**\r\n     * List of mipmap levels.\r\n     * The first element is the base level, the last element is the smallest mipmap level (if more than one mipmap level is present)\r\n     */\r\n    mipmaps: Array<IMipmap>;\r\n\r\n    /**\r\n     * Whether the texture data is in gamma space or not\r\n     */\r\n    isInGammaSpace: boolean;\r\n\r\n    /**\r\n     * Whether the texture has an alpha channel or not\r\n     */\r\n    hasAlpha: boolean;\r\n\r\n    /**\r\n     * The name of the transcoder used to transcode the texture\r\n     */\r\n    transcoderName: string;\r\n\r\n    /**\r\n     * The errors (if any) encountered during the decoding process\r\n     */\r\n    errors?: string;\r\n}\r\n\r\n/**\r\n * Defines a mipmap level\r\n */\r\nexport interface IMipmap {\r\n    /**\r\n     * The data of the mipmap level\r\n     */\r\n    data: Uint8Array | null;\r\n\r\n    /**\r\n     * The width of the mipmap level\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The height of the mipmap level\r\n     */\r\n    height: number;\r\n}\r\n\r\n/**\r\n * The compressed texture formats supported by the browser\r\n */\r\nexport interface ICompressedFormatCapabilities {\r\n    /**\r\n     * Whether the browser supports ASTC\r\n     */\r\n    astc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports BPTC\r\n     */\r\n    bptc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports S3TC\r\n     */\r\n    s3tc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports PVRTC\r\n     */\r\n    pvrtc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports ETC2\r\n     */\r\n    etc2?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports ETC1\r\n     */\r\n    etc1?: boolean;\r\n}\r\n\r\n/**\r\n * Options passed to the KTX2 decode function\r\n */\r\nexport interface IKTX2DecoderOptions {\r\n    /** use RGBA format if ASTC and BC7 are not available as transcoded format */\r\n    useRGBAIfASTCBC7NotAvailableWhenUASTC?: boolean;\r\n\r\n    /** force to always use (uncompressed) RGBA for transcoded format */\r\n    forceRGBA?: boolean;\r\n\r\n    /** force to always use (uncompressed) R8 for transcoded format */\r\n    forceR8?: boolean;\r\n\r\n    /** force to always use (uncompressed) RG8 for transcoded format */\r\n    forceRG8?: boolean;\r\n\r\n    /**\r\n     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\r\n     *      UniversalTranscoder_UASTC_ASTC\r\n     *      UniversalTranscoder_UASTC_BC7\r\n     *      UniversalTranscoder_UASTC_RGBA_UNORM\r\n     *      UniversalTranscoder_UASTC_RGBA_SRGB\r\n     *      UniversalTranscoder_UASTC_R8_UNORM\r\n     *      UniversalTranscoder_UASTC_RG8_UNORM\r\n     *      MSCTranscoder\r\n     */\r\n    bypassTranscoders?: string[];\r\n\r\n    /**\r\n     * Custom decision tree to apply after the default decision tree has selected a transcoding format.\r\n     * Allows the user to override the default decision tree selection.\r\n     * The decision tree can use the INode.transcodeFormat property to base its decision on the transcoding format selected by the default decision tree.\r\n     */\r\n    transcodeFormatDecisionTree?: IDecisionTree;\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport { DataReader } from \"./Misc/dataReader\";\r\n\r\n/** @internal */\r\nexport enum SupercompressionScheme {\r\n    None = 0,\r\n    BasisLZ = 1,\r\n    ZStandard = 2,\r\n    ZLib = 3,\r\n}\r\n\r\nconst enum DFDModel {\r\n    ETC1S = 163,\r\n    UASTC = 166,\r\n}\r\n\r\nconst enum DFDChannel_ETC1S {\r\n    RGB = 0,\r\n    RRR = 3,\r\n    GGG = 4,\r\n    AAA = 15,\r\n}\r\n\r\nconst enum DFDChannel_UASTC {\r\n    RGB = 0,\r\n    RGBA = 3,\r\n    RRR = 4,\r\n    RRRG = 5,\r\n}\r\n\r\nconst enum DFDTransferFunction {\r\n    linear = 1,\r\n    sRGB = 2,\r\n}\r\n\r\n/** @internal */\r\nexport interface IKTX2_Header {\r\n    vkFormat: number;\r\n    typeSize: number;\r\n    pixelWidth: number;\r\n    pixelHeight: number;\r\n    pixelDepth: number;\r\n    layerCount: number;\r\n    faceCount: number;\r\n    levelCount: number;\r\n    supercompressionScheme: number;\r\n    dfdByteOffset: number;\r\n    dfdByteLength: number;\r\n    kvdByteOffset: number;\r\n    kvdByteLength: number;\r\n    sgdByteOffset: number;\r\n    sgdByteLength: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IKTX2_Level {\r\n    byteOffset: number;\r\n    byteLength: number;\r\n    uncompressedByteLength: number;\r\n}\r\n\r\ninterface IKTX2_Sample {\r\n    bitOffset: number;\r\n    bitLength: number;\r\n    channelType: number;\r\n    channelFlags: number;\r\n    samplePosition: number[];\r\n    sampleLower: number;\r\n    sampleUpper: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IKTX2_DFD {\r\n    vendorId: number;\r\n    descriptorType: number;\r\n    versionNumber: number;\r\n    descriptorBlockSize: number;\r\n    colorModel: number;\r\n    colorPrimaries: number;\r\n    transferFunction: number;\r\n    flags: number;\r\n    texelBlockDimension: {\r\n        x: number;\r\n        y: number;\r\n        z: number;\r\n        w: number;\r\n    };\r\n    bytesPlane: Array<number>;\r\n    numSamples: number;\r\n    samples: Array<IKTX2_Sample>;\r\n}\r\n\r\n/** @internal */\r\nexport interface IKTX2_ImageDesc {\r\n    imageFlags: number;\r\n    rgbSliceByteOffset: number;\r\n    rgbSliceByteLength: number;\r\n    alphaSliceByteOffset: number;\r\n    alphaSliceByteLength: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IKTX2_SupercompressionGlobalData {\r\n    endpointCount?: number;\r\n    selectorCount?: number;\r\n    endpointsByteLength?: number;\r\n    selectorsByteLength?: number;\r\n    tablesByteLength?: number;\r\n    extendedByteLength?: number;\r\n    imageDescs?: Array<IKTX2_ImageDesc>;\r\n    endpointsData?: Uint8Array;\r\n    selectorsData?: Uint8Array;\r\n    tablesData?: Uint8Array;\r\n    extendedData?: Uint8Array;\r\n}\r\n\r\nexport class KTX2FileReader {\r\n    private _data: Uint8Array;\r\n    private _header: IKTX2_Header;\r\n    private _levels: Array<IKTX2_Level>;\r\n    private _dfdBlock: IKTX2_DFD;\r\n    private _supercompressionGlobalData: IKTX2_SupercompressionGlobalData;\r\n\r\n    /**\r\n     * Will throw an exception if the file can't be parsed\r\n     * @param data\r\n     */\r\n    constructor(data: Uint8Array) {\r\n        this._data = data;\r\n    }\r\n\r\n    public get data(): Uint8Array {\r\n        return this._data;\r\n    }\r\n\r\n    public get header(): IKTX2_Header {\r\n        return this._header;\r\n    }\r\n\r\n    public get levels(): Array<IKTX2_Level> {\r\n        return this._levels;\r\n    }\r\n\r\n    public get dfdBlock(): IKTX2_DFD {\r\n        return this._dfdBlock;\r\n    }\r\n\r\n    public get supercompressionGlobalData(): IKTX2_SupercompressionGlobalData {\r\n        return this._supercompressionGlobalData;\r\n    }\r\n\r\n    public isValid() {\r\n        return KTX2FileReader.IsValid(this._data);\r\n    }\r\n\r\n    public parse() {\r\n        let offsetInFile = 12; // skip the header\r\n\r\n        /**\r\n         * Get the header\r\n         */\r\n        const hdrReader = new DataReader(this._data, offsetInFile, 17 * 4);\r\n\r\n        const header = (this._header = {\r\n            vkFormat: hdrReader.readUint32(),\r\n            typeSize: hdrReader.readUint32(),\r\n            pixelWidth: hdrReader.readUint32(),\r\n            pixelHeight: hdrReader.readUint32(),\r\n            pixelDepth: hdrReader.readUint32(),\r\n            layerCount: hdrReader.readUint32(),\r\n            faceCount: hdrReader.readUint32(),\r\n            levelCount: hdrReader.readUint32(),\r\n            supercompressionScheme: hdrReader.readUint32(),\r\n\r\n            dfdByteOffset: hdrReader.readUint32(),\r\n            dfdByteLength: hdrReader.readUint32(),\r\n            kvdByteOffset: hdrReader.readUint32(),\r\n            kvdByteLength: hdrReader.readUint32(),\r\n            sgdByteOffset: hdrReader.readUint64(),\r\n            sgdByteLength: hdrReader.readUint64(),\r\n        });\r\n\r\n        if (header.pixelDepth > 0) {\r\n            throw new Error(`Failed to parse KTX2 file - Only 2D textures are currently supported.`);\r\n        }\r\n\r\n        if (header.layerCount > 1) {\r\n            throw new Error(`Failed to parse KTX2 file - Array textures are not currently supported.`);\r\n        }\r\n\r\n        if (header.faceCount > 1) {\r\n            throw new Error(`Failed to parse KTX2 file - Cube textures are not currently supported.`);\r\n        }\r\n\r\n        offsetInFile += hdrReader.byteOffset;\r\n\r\n        /**\r\n         * Get the levels\r\n         */\r\n        let levelCount = Math.max(1, header.levelCount);\r\n\r\n        const levelReader = new DataReader(this._data, offsetInFile, levelCount * 3 * (2 * 4));\r\n\r\n        const levels: Array<IKTX2_Level> = (this._levels = []);\r\n\r\n        while (levelCount--) {\r\n            levels.push({\r\n                byteOffset: levelReader.readUint64(),\r\n                byteLength: levelReader.readUint64(),\r\n                uncompressedByteLength: levelReader.readUint64(),\r\n            });\r\n        }\r\n\r\n        offsetInFile += levelReader.byteOffset;\r\n\r\n        /**\r\n         * Get the data format descriptor (DFD) blocks\r\n         */\r\n        const dfdReader = new DataReader(this._data, header.dfdByteOffset, header.dfdByteLength);\r\n\r\n        const dfdBlock = (this._dfdBlock = {\r\n            vendorId: dfdReader.skipBytes(4 /* skip totalSize */).readUint16(),\r\n            descriptorType: dfdReader.readUint16(),\r\n            versionNumber: dfdReader.readUint16(),\r\n            descriptorBlockSize: dfdReader.readUint16(),\r\n            colorModel: dfdReader.readUint8(),\r\n            colorPrimaries: dfdReader.readUint8(),\r\n            transferFunction: dfdReader.readUint8(),\r\n            flags: dfdReader.readUint8(),\r\n            texelBlockDimension: {\r\n                x: dfdReader.readUint8() + 1,\r\n                y: dfdReader.readUint8() + 1,\r\n                z: dfdReader.readUint8() + 1,\r\n                w: dfdReader.readUint8() + 1,\r\n            },\r\n            bytesPlane: [\r\n                dfdReader.readUint8() /* bytesPlane0 */,\r\n                dfdReader.readUint8() /* bytesPlane1 */,\r\n                dfdReader.readUint8() /* bytesPlane2 */,\r\n                dfdReader.readUint8() /* bytesPlane3 */,\r\n                dfdReader.readUint8() /* bytesPlane4 */,\r\n                dfdReader.readUint8() /* bytesPlane5 */,\r\n                dfdReader.readUint8() /* bytesPlane6 */,\r\n                dfdReader.readUint8() /* bytesPlane7 */,\r\n            ],\r\n            numSamples: 0,\r\n            samples: new Array<IKTX2_Sample>(),\r\n        });\r\n\r\n        dfdBlock.numSamples = (dfdBlock.descriptorBlockSize - 24) / 16;\r\n\r\n        for (let i = 0; i < dfdBlock.numSamples; i++) {\r\n            const sample = {\r\n                bitOffset: dfdReader.readUint16(),\r\n                bitLength: dfdReader.readUint8() + 1,\r\n                channelType: dfdReader.readUint8(),\r\n                channelFlags: 0,\r\n                samplePosition: [\r\n                    dfdReader.readUint8() /* samplePosition0 */,\r\n                    dfdReader.readUint8() /* samplePosition1 */,\r\n                    dfdReader.readUint8() /* samplePosition2 */,\r\n                    dfdReader.readUint8() /* samplePosition3 */,\r\n                ],\r\n                sampleLower: dfdReader.readUint32(),\r\n                sampleUpper: dfdReader.readUint32(),\r\n            };\r\n\r\n            sample.channelFlags = (sample.channelType & 0xf0) >> 4;\r\n            sample.channelType = sample.channelType & 0x0f;\r\n\r\n            dfdBlock.samples.push(sample);\r\n        }\r\n\r\n        /**\r\n         * Get the Supercompression Global Data (sgd)\r\n         */\r\n        const sgd: IKTX2_SupercompressionGlobalData = (this._supercompressionGlobalData = {});\r\n\r\n        if (header.sgdByteLength > 0) {\r\n            const sgdReader = new DataReader(this._data, header.sgdByteOffset, header.sgdByteLength);\r\n\r\n            sgd.endpointCount = sgdReader.readUint16();\r\n            sgd.selectorCount = sgdReader.readUint16();\r\n            sgd.endpointsByteLength = sgdReader.readUint32();\r\n            sgd.selectorsByteLength = sgdReader.readUint32();\r\n            sgd.tablesByteLength = sgdReader.readUint32();\r\n            sgd.extendedByteLength = sgdReader.readUint32();\r\n            sgd.imageDescs = [];\r\n\r\n            const imageCount = this._getImageCount();\r\n\r\n            for (let i = 0; i < imageCount; i++) {\r\n                sgd.imageDescs.push({\r\n                    imageFlags: sgdReader.readUint32(),\r\n                    rgbSliceByteOffset: sgdReader.readUint32(),\r\n                    rgbSliceByteLength: sgdReader.readUint32(),\r\n                    alphaSliceByteOffset: sgdReader.readUint32(),\r\n                    alphaSliceByteLength: sgdReader.readUint32(),\r\n                });\r\n            }\r\n\r\n            const endpointsByteOffset = header.sgdByteOffset + sgdReader.byteOffset;\r\n            const selectorsByteOffset = endpointsByteOffset + sgd.endpointsByteLength;\r\n            const tablesByteOffset = selectorsByteOffset + sgd.selectorsByteLength;\r\n            const extendedByteOffset = tablesByteOffset + sgd.tablesByteLength;\r\n\r\n            sgd.endpointsData = new Uint8Array(this._data.buffer, this._data.byteOffset + endpointsByteOffset, sgd.endpointsByteLength);\r\n            sgd.selectorsData = new Uint8Array(this._data.buffer, this._data.byteOffset + selectorsByteOffset, sgd.selectorsByteLength);\r\n            sgd.tablesData = new Uint8Array(this._data.buffer, this._data.byteOffset + tablesByteOffset, sgd.tablesByteLength);\r\n            sgd.extendedData = new Uint8Array(this._data.buffer, this._data.byteOffset + extendedByteOffset, sgd.extendedByteLength);\r\n        }\r\n    }\r\n\r\n    private _getImageCount(): number {\r\n        let layerPixelDepth = Math.max(this._header.pixelDepth, 1);\r\n        for (let i = 1; i < this._header.levelCount; i++) {\r\n            layerPixelDepth += Math.max(this._header.pixelDepth >> i, 1);\r\n        }\r\n\r\n        return Math.max(this._header.layerCount, 1) * this._header.faceCount * layerPixelDepth;\r\n    }\r\n\r\n    public get textureFormat(): KTX2.SourceTextureFormat {\r\n        return this._dfdBlock.colorModel === DFDModel.UASTC ? KTX2.SourceTextureFormat.UASTC4x4 : KTX2.SourceTextureFormat.ETC1S;\r\n    }\r\n\r\n    public get hasAlpha(): boolean {\r\n        const tformat = this.textureFormat;\r\n\r\n        switch (tformat) {\r\n            case KTX2.SourceTextureFormat.ETC1S:\r\n                return (\r\n                    this._dfdBlock.numSamples === 2 &&\r\n                    (this._dfdBlock.samples[0].channelType === DFDChannel_ETC1S.AAA || this._dfdBlock.samples[1].channelType === DFDChannel_ETC1S.AAA)\r\n                );\r\n\r\n            case KTX2.SourceTextureFormat.UASTC4x4:\r\n                return this._dfdBlock.samples[0].channelType === DFDChannel_UASTC.RGBA;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public get needZSTDDecoder(): boolean {\r\n        return this._header.supercompressionScheme === SupercompressionScheme.ZStandard;\r\n    }\r\n\r\n    public get isInGammaSpace(): boolean {\r\n        return this._dfdBlock.transferFunction === DFDTransferFunction.sRGB;\r\n    }\r\n\r\n    public static IsValid(data: ArrayBufferView): boolean {\r\n        if (data.byteLength >= 12) {\r\n            // '«', 'K', 'T', 'X', ' ', '2', '0', '»', '\\r', '\\n', '\\x1A', '\\n'\r\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\r\n            if (\r\n                identifier[0] === 0xab &&\r\n                identifier[1] === 0x4b &&\r\n                identifier[2] === 0x54 &&\r\n                identifier[3] === 0x58 &&\r\n                identifier[4] === 0x20 &&\r\n                identifier[5] === 0x32 &&\r\n                identifier[6] === 0x30 &&\r\n                identifier[7] === 0xbb &&\r\n                identifier[8] === 0x0d &&\r\n                identifier[9] === 0x0a &&\r\n                identifier[10] === 0x1a &&\r\n                identifier[11] === 0x0a\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","/**\r\n * Utility class for reading from a data buffer\r\n */\r\nexport class DataReader {\r\n    /**\r\n     * The current byte offset from the beginning of the data buffer.\r\n     */\r\n    public get byteOffset() {\r\n        return this._dataByteOffset;\r\n    }\r\n\r\n    private _dataView: DataView;\r\n    private _dataByteOffset: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param buffer The buffer to set\r\n     * @param byteOffset The starting offset in the buffer\r\n     * @param byteLength The byte length of the buffer\r\n     */\r\n    constructor(buffer: ArrayBuffer | ArrayBufferView, byteOffset?: number, byteLength?: number) {\r\n        if ((buffer as ArrayBufferView).buffer) {\r\n            this._dataView = new DataView(\r\n                (buffer as ArrayBufferView).buffer,\r\n                (buffer as ArrayBufferView).byteOffset + (byteOffset ?? 0),\r\n                byteLength ?? (buffer as ArrayBufferView).byteLength\r\n            );\r\n        } else {\r\n            this._dataView = new DataView(buffer as ArrayBuffer, byteOffset ?? 0, byteLength ?? (buffer as ArrayBuffer).byteLength);\r\n        }\r\n\r\n        this._dataByteOffset = 0;\r\n    }\r\n\r\n    /**\r\n     * Read a unsigned 8-bit integer from the currently loaded data range.\r\n     * @returns The 8-bit integer read\r\n     */\r\n    public readUint8(): number {\r\n        const value = this._dataView.getUint8(this._dataByteOffset);\r\n        this._dataByteOffset += 1;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a signed 8-bit integer from the currently loaded data range.\r\n     * @returns The 8-bit integer read\r\n     */\r\n    public readInt8(): number {\r\n        const value = this._dataView.getInt8(this._dataByteOffset);\r\n        this._dataByteOffset += 1;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a unsigned 16-bit integer from the currently loaded data range.\r\n     * @returns The 16-bit integer read\r\n     */\r\n    public readUint16(): number {\r\n        const value = this._dataView.getUint16(this._dataByteOffset, true);\r\n        this._dataByteOffset += 2;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a signed 16-bit integer from the currently loaded data range.\r\n     * @returns The 16-bit integer read\r\n     */\r\n    public readInt16(): number {\r\n        const value = this._dataView.getInt16(this._dataByteOffset, true);\r\n        this._dataByteOffset += 2;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a unsigned 32-bit integer from the currently loaded data range.\r\n     * @returns The 32-bit integer read\r\n     */\r\n    public readUint32(): number {\r\n        const value = this._dataView.getUint32(this._dataByteOffset, true);\r\n        this._dataByteOffset += 4;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a signed 32-bit integer from the currently loaded data range.\r\n     * @returns The 32-bit integer read\r\n     */\r\n    public readInt32(): number {\r\n        const value = this._dataView.getInt32(this._dataByteOffset, true);\r\n        this._dataByteOffset += 4;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a unsigned 32-bit integer from the currently loaded data range.\r\n     * @returns The 32-bit integer read\r\n     */\r\n    public readUint64(): number {\r\n        // split 64-bit number into two 32-bit (4-byte) parts\r\n        const left = this._dataView.getUint32(this._dataByteOffset, true);\r\n        const right = this._dataView.getUint32(this._dataByteOffset + 4, true);\r\n\r\n        // combine the two 32-bit values\r\n        const combined = left + 2 ** 32 * right; // That was weird..Keeping it for posterity: true ? left + 2 ** 32 * right : 2 ** 32 * left + right;\r\n\r\n        /*if (!Number.isSafeInteger(combined)) {\r\n            console.warn('DataReader: ' + combined + ' exceeds MAX_SAFE_INTEGER. Precision may be lost.');\r\n        }*/\r\n\r\n        this._dataByteOffset += 8;\r\n        return combined;\r\n    }\r\n\r\n    /**\r\n     * Read a byte array from the currently loaded data range.\r\n     * @param byteLength The byte length to read\r\n     * @returns The byte array read\r\n     */\r\n    public readUint8Array(byteLength: number): Uint8Array {\r\n        const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);\r\n        this._dataByteOffset += byteLength;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Skips the given byte length the currently loaded data range.\r\n     * @param byteLength The byte length to skip\r\n     * @returns This instance\r\n     */\r\n    public skipBytes(byteLength: number) {\r\n        this._dataByteOffset += byteLength;\r\n        return this;\r\n    }\r\n}\r\n","declare function postMessage(message: any, transfer?: any[]): void;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class WASMMemoryManager {\r\n    public static LoadBinariesFromCurrentThread = true;\r\n    public static InitialMemoryPages = (1 * 1024 * 1024) >> 16; // 1 Mbytes\r\n\r\n    private static _RequestId = 0;\r\n\r\n    public static LoadWASM(path: string): Promise<ArrayBuffer> {\r\n        if (this.LoadBinariesFromCurrentThread) {\r\n            return new Promise((resolve, reject) => {\r\n                fetch(path)\r\n                    .then((response) => {\r\n                        if (response.ok) {\r\n                            return response.arrayBuffer();\r\n                        }\r\n                        throw new Error(`Could not fetch the wasm component from \"${path}\": ${response.status} - ${response.statusText}`);\r\n                    })\r\n                    .then((wasmBinary) => resolve(wasmBinary))\r\n                    .catch((reason) => {\r\n                        reject(reason);\r\n                    });\r\n            });\r\n        }\r\n\r\n        const id = this._RequestId++;\r\n\r\n        return new Promise((resolve) => {\r\n            const wasmLoadedHandler = (msg: any) => {\r\n                if (msg.data.action === \"wasmLoaded\" && msg.data.id === id) {\r\n                    self.removeEventListener(\"message\", wasmLoadedHandler);\r\n                    resolve(msg.data.wasmBinary);\r\n                }\r\n            };\r\n\r\n            self.addEventListener(\"message\", wasmLoadedHandler);\r\n\r\n            postMessage({ action: \"loadWASM\", path: path, id: id });\r\n        });\r\n    }\r\n\r\n    private _memory: WebAssembly.Memory;\r\n    private _numPages: number;\r\n    private _memoryView: Uint8Array;\r\n    private _memoryViewByteLength: number;\r\n    private _memoryViewOffset: number;\r\n\r\n    constructor(initialMemoryPages: number = WASMMemoryManager.InitialMemoryPages) {\r\n        this._numPages = initialMemoryPages;\r\n\r\n        this._memory = new WebAssembly.Memory({ initial: this._numPages });\r\n        this._memoryViewByteLength = this._numPages << 16;\r\n        this._memoryViewOffset = 0;\r\n        this._memoryView = new Uint8Array(this._memory.buffer, this._memoryViewOffset, this._memoryViewByteLength);\r\n    }\r\n\r\n    public get wasmMemory(): WebAssembly.Memory {\r\n        return this._memory;\r\n    }\r\n\r\n    public getMemoryView(numPages: number, offset: number = 0, byteLength?: number): Uint8Array {\r\n        byteLength = byteLength ?? numPages << 16;\r\n\r\n        if (this._numPages < numPages) {\r\n            this._memory.grow(numPages - this._numPages);\r\n            this._numPages = numPages;\r\n            this._memoryView = new Uint8Array(this._memory.buffer, offset, byteLength);\r\n            this._memoryViewByteLength = byteLength;\r\n            this._memoryViewOffset = offset;\r\n        } else {\r\n            this._memoryView = new Uint8Array(this._memory.buffer, offset, byteLength);\r\n            this._memoryViewByteLength = byteLength;\r\n            this._memoryViewOffset = offset;\r\n        }\r\n\r\n        return this._memoryView;\r\n    }\r\n}\r\n","import * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport type { Transcoder } from \"./transcoder\";\r\nimport { WASMMemoryManager } from \"./wasmMemoryManager\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class TranscoderManager {\r\n    public static _Transcoders: Array<typeof Transcoder> = [];\r\n\r\n    public static RegisterTranscoder(transcoder: typeof Transcoder) {\r\n        TranscoderManager._Transcoders.push(transcoder);\r\n    }\r\n\r\n    private static _TranscoderInstances: { [key: string]: Array<Transcoder> } = {};\r\n\r\n    private _wasmMemoryManager: WASMMemoryManager;\r\n\r\n    public findTranscoder(src: KTX2.SourceTextureFormat, dst: KTX2.TranscodeTarget, isInGammaSpace: boolean, bypass?: string[]): Transcoder | null {\r\n        let transcoder: Transcoder | null = null;\r\n\r\n        const key = KTX2.SourceTextureFormat[src] + \"_\" + KTX2.TranscodeTarget[dst];\r\n\r\n        for (let i = 0; i < TranscoderManager._Transcoders.length; ++i) {\r\n            if (TranscoderManager._Transcoders[i].CanTranscode(src, dst, isInGammaSpace) && (!bypass || bypass.indexOf(TranscoderManager._Transcoders[i].Name) < 0)) {\r\n                transcoder = this._getExistingTranscoder(key, TranscoderManager._Transcoders[i].Name);\r\n                if (!transcoder) {\r\n                    transcoder = new TranscoderManager._Transcoders[i]();\r\n                    transcoder!.initialize();\r\n                    if (transcoder!.needMemoryManager()) {\r\n                        if (!this._wasmMemoryManager) {\r\n                            this._wasmMemoryManager = new WASMMemoryManager();\r\n                        }\r\n                        transcoder!.setMemoryManager(this._wasmMemoryManager);\r\n                    }\r\n                    if (!TranscoderManager._TranscoderInstances[key]) {\r\n                        TranscoderManager._TranscoderInstances[key] = [];\r\n                    }\r\n                    TranscoderManager._TranscoderInstances[key].push(transcoder);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return transcoder;\r\n    }\r\n\r\n    private _getExistingTranscoder(key: string, transcoderName: string): Transcoder | null {\r\n        const transcoders = TranscoderManager._TranscoderInstances[key];\r\n\r\n        if (transcoders) {\r\n            for (let t = 0; t < transcoders.length; ++t) {\r\n                const transcoder = transcoders[t];\r\n                if (transcoderName === transcoder.getName()) {\r\n                    return transcoder;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport type { WASMMemoryManager } from \"./wasmMemoryManager\";\r\nimport type { KTX2FileReader, IKTX2_ImageDesc } from \"./ktx2FileReader\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class Transcoder {\r\n    public static CanTranscode(src: KTX2.SourceTextureFormat, dst: KTX2.TranscodeTarget, isInGammaSpace: boolean): boolean {\r\n        return false;\r\n    }\r\n\r\n    public static Name = \"Transcoder\";\r\n\r\n    public getName(): string {\r\n        return Transcoder.Name;\r\n    }\r\n\r\n    public initialize(): void {}\r\n\r\n    public needMemoryManager(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public setMemoryManager(memoryMgr: WASMMemoryManager): void {}\r\n\r\n    public transcode(\r\n        src: KTX2.SourceTextureFormat,\r\n        dst: KTX2.TranscodeTarget,\r\n        level: number,\r\n        width: number,\r\n        height: number,\r\n        uncompressedByteLength: number,\r\n        ktx2Reader: KTX2FileReader,\r\n        imageDesc: IKTX2_ImageDesc | null,\r\n        encodedData: Uint8Array\r\n    ): Promise<Uint8Array | null> {\r\n        return Promise.resolve(null);\r\n    }\r\n}\r\n","import type * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport { Transcoder } from \"../transcoder\";\r\nimport { WASMMemoryManager } from \"../wasmMemoryManager\";\r\nimport type { KTX2FileReader, IKTX2_ImageDesc } from \"../ktx2FileReader\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class LiteTranscoder extends Transcoder {\r\n    private _modulePath: string;\r\n    private _modulePromise: Promise<{ module: any }>;\r\n    private _memoryManager: WASMMemoryManager;\r\n    protected _transcodeInPlace: boolean;\r\n\r\n    protected _loadModule(): Promise<{ module: any }> {\r\n        if (this._modulePromise) {\r\n            return this._modulePromise;\r\n        }\r\n\r\n        this._modulePromise = WASMMemoryManager.LoadWASM(this._modulePath).then((wasmBinary) => {\r\n            return new Promise((resolve) => {\r\n                WebAssembly.instantiate(wasmBinary as ArrayBuffer, { env: { memory: this._memoryManager.wasmMemory } }).then((moduleWrapper) => {\r\n                    resolve({ module: moduleWrapper.instance.exports });\r\n                });\r\n            });\r\n        });\r\n\r\n        return this._modulePromise;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected get memoryManager(): WASMMemoryManager {\r\n        return this._memoryManager;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected setModulePath(modulePath: string): void {\r\n        this._modulePath = modulePath;\r\n    }\r\n\r\n    public initialize(): void {\r\n        this._transcodeInPlace = true;\r\n    }\r\n\r\n    public needMemoryManager(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public setMemoryManager(memoryMgr: WASMMemoryManager): void {\r\n        this._memoryManager = memoryMgr;\r\n    }\r\n\r\n    public transcode(\r\n        src: KTX2.SourceTextureFormat,\r\n        dst: KTX2.TranscodeTarget,\r\n        level: number,\r\n        width: number,\r\n        height: number,\r\n        uncompressedByteLength: number,\r\n        ktx2Reader: KTX2FileReader,\r\n        imageDesc: IKTX2_ImageDesc | null,\r\n        encodedData: Uint8Array\r\n    ): Promise<Uint8Array | null> {\r\n        return this._loadModule().then((moduleWrapper: any) => {\r\n            const transcoder: any = moduleWrapper.module;\r\n            const [textureView, uncompressedTextureView, nBlocks] = this._prepareTranscoding(width, height, uncompressedByteLength, encodedData);\r\n\r\n            return transcoder.transcode(nBlocks) === 0 ? (this._transcodeInPlace ? textureView.slice() : uncompressedTextureView!.slice()) : null;\r\n        });\r\n    }\r\n\r\n    protected _prepareTranscoding(\r\n        width: number,\r\n        height: number,\r\n        uncompressedByteLength: number,\r\n        encodedData: Uint8Array,\r\n        uncompressedNumComponents?: number\r\n    ): [Uint8Array, Uint8Array | null, number] {\r\n        const nBlocks = ((width + 3) >> 2) * ((height + 3) >> 2);\r\n\r\n        if (uncompressedNumComponents !== undefined) {\r\n            uncompressedByteLength = width * ((height + 3) >> 2) * 4 * uncompressedNumComponents;\r\n        }\r\n\r\n        const texMemoryPages = ((nBlocks * 16 + 65535 + (this._transcodeInPlace ? 0 : uncompressedByteLength)) >> 16) + 1;\r\n\r\n        const textureView = this.memoryManager.getMemoryView(texMemoryPages, 65536, nBlocks * 16);\r\n\r\n        const uncompressedTextureView = this._transcodeInPlace\r\n            ? null\r\n            : new Uint8Array(\r\n                  this._memoryManager.wasmMemory.buffer,\r\n                  65536 + nBlocks * 16,\r\n                  uncompressedNumComponents !== undefined ? width * height * uncompressedNumComponents : uncompressedByteLength\r\n              );\r\n\r\n        textureView.set(encodedData);\r\n\r\n        return [textureView, uncompressedTextureView, nBlocks];\r\n    }\r\n}\r\n","import * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport { LiteTranscoder } from \"./liteTranscoder\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class LiteTranscoder_UASTC_ASTC extends LiteTranscoder {\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    public static WasmModuleURL = \"https://preview.babylonjs.com/ktx2Transcoders/1/uastc_astc.wasm\";\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static CanTranscode(src: KTX2.SourceTextureFormat, dst: KTX2.TranscodeTarget, isInGammaSpace: boolean): boolean {\r\n        return src === KTX2.SourceTextureFormat.UASTC4x4 && dst === KTX2.TranscodeTarget.ASTC_4X4_RGBA;\r\n    }\r\n\r\n    public static Name = \"UniversalTranscoder_UASTC_ASTC\";\r\n\r\n    public getName(): string {\r\n        return LiteTranscoder_UASTC_ASTC.Name;\r\n    }\r\n\r\n    public initialize(): void {\r\n        super.initialize();\r\n        this.setModulePath(LiteTranscoder_UASTC_ASTC.WasmModuleURL);\r\n    }\r\n}\r\n","import * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport { LiteTranscoder } from \"./liteTranscoder\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class LiteTranscoder_UASTC_BC7 extends LiteTranscoder {\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    public static WasmModuleURL = \"https://preview.babylonjs.com/ktx2Transcoders/1/uastc_bc7.wasm\";\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static CanTranscode(src: KTX2.SourceTextureFormat, dst: KTX2.TranscodeTarget, isInGammaSpace: boolean): boolean {\r\n        return src === KTX2.SourceTextureFormat.UASTC4x4 && dst === KTX2.TranscodeTarget.BC7_RGBA;\r\n    }\r\n\r\n    public static Name = \"UniversalTranscoder_UASTC_BC7\";\r\n\r\n    public getName(): string {\r\n        return LiteTranscoder_UASTC_BC7.Name;\r\n    }\r\n\r\n    public initialize(): void {\r\n        super.initialize();\r\n        this.setModulePath(LiteTranscoder_UASTC_BC7.WasmModuleURL);\r\n    }\r\n}\r\n","import * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport { LiteTranscoder } from \"./liteTranscoder\";\r\nimport type { KTX2FileReader, IKTX2_ImageDesc } from \"../ktx2FileReader\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class LiteTranscoder_UASTC_RGBA_UNORM extends LiteTranscoder {\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder (unorm)\r\n     */\r\n    public static WasmModuleURL = \"https://preview.babylonjs.com/ktx2Transcoders/1/uastc_rgba8_unorm_v2.wasm\";\r\n\r\n    public static CanTranscode(src: KTX2.SourceTextureFormat, dst: KTX2.TranscodeTarget, isInGammaSpace: boolean): boolean {\r\n        return src === KTX2.SourceTextureFormat.UASTC4x4 && dst === KTX2.TranscodeTarget.RGBA32 && !isInGammaSpace;\r\n    }\r\n\r\n    public static Name = \"UniversalTranscoder_UASTC_RGBA_UNORM\";\r\n\r\n    public getName(): string {\r\n        return LiteTranscoder_UASTC_RGBA_UNORM.Name;\r\n    }\r\n\r\n    public initialize(): void {\r\n        super.initialize();\r\n        this._transcodeInPlace = false;\r\n        this.setModulePath(LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL);\r\n    }\r\n\r\n    public transcode(\r\n        src: KTX2.SourceTextureFormat,\r\n        dst: KTX2.TranscodeTarget,\r\n        level: number,\r\n        width: number,\r\n        height: number,\r\n        uncompressedByteLength: number,\r\n        ktx2Reader: KTX2FileReader,\r\n        imageDesc: IKTX2_ImageDesc | null,\r\n        encodedData: Uint8Array\r\n    ): Promise<Uint8Array | null> {\r\n        return this._loadModule().then((moduleWrapper: any) => {\r\n            const transcoder: any = moduleWrapper.module;\r\n            const [, uncompressedTextureView] = this._prepareTranscoding(width, height, uncompressedByteLength, encodedData, 4);\r\n\r\n            return transcoder.decode(width, height) === 0 ? uncompressedTextureView!.slice() : null;\r\n        });\r\n    }\r\n}\r\n","import * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport { LiteTranscoder } from \"./liteTranscoder\";\r\nimport type { KTX2FileReader, IKTX2_ImageDesc } from \"../ktx2FileReader\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class LiteTranscoder_UASTC_RGBA_SRGB extends LiteTranscoder {\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder (srgb)\r\n     */\r\n    public static WasmModuleURL = \"https://preview.babylonjs.com/ktx2Transcoders/1/uastc_rgba8_srgb_v2.wasm\";\r\n\r\n    public static CanTranscode(src: KTX2.SourceTextureFormat, dst: KTX2.TranscodeTarget, isInGammaSpace: boolean): boolean {\r\n        return src === KTX2.SourceTextureFormat.UASTC4x4 && dst === KTX2.TranscodeTarget.RGBA32 && isInGammaSpace;\r\n    }\r\n\r\n    public static Name = \"UniversalTranscoder_UASTC_RGBA_SRGB\";\r\n\r\n    public getName(): string {\r\n        return LiteTranscoder_UASTC_RGBA_SRGB.Name;\r\n    }\r\n\r\n    public initialize(): void {\r\n        super.initialize();\r\n        this._transcodeInPlace = false;\r\n        this.setModulePath(LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL);\r\n    }\r\n\r\n    public transcode(\r\n        src: KTX2.SourceTextureFormat,\r\n        dst: KTX2.TranscodeTarget,\r\n        level: number,\r\n        width: number,\r\n        height: number,\r\n        uncompressedByteLength: number,\r\n        ktx2Reader: KTX2FileReader,\r\n        imageDesc: IKTX2_ImageDesc | null,\r\n        encodedData: Uint8Array\r\n    ): Promise<Uint8Array | null> {\r\n        return this._loadModule().then((moduleWrapper: any) => {\r\n            const transcoder: any = moduleWrapper.module;\r\n            const [, uncompressedTextureView] = this._prepareTranscoding(width, height, uncompressedByteLength, encodedData, 4);\r\n\r\n            return transcoder.decode(width, height) === 0 ? uncompressedTextureView!.slice() : null;\r\n        });\r\n    }\r\n}\r\n","import * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport { LiteTranscoder } from \"./liteTranscoder\";\r\nimport type { KTX2FileReader, IKTX2_ImageDesc } from \"../ktx2FileReader\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class LiteTranscoder_UASTC_R8_UNORM extends LiteTranscoder {\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder (srgb)\r\n     */\r\n    public static WasmModuleURL = \"https://preview.babylonjs.com/1/uastc_r8_unorm.wasm\";\r\n\r\n    public static CanTranscode(src: KTX2.SourceTextureFormat, dst: KTX2.TranscodeTarget, isInGammaSpace: boolean): boolean {\r\n        return src === KTX2.SourceTextureFormat.UASTC4x4 && dst === KTX2.TranscodeTarget.R8;\r\n    }\r\n\r\n    public static Name = \"UniversalTranscoder_UASTC_R8_UNORM\";\r\n\r\n    public getName(): string {\r\n        return LiteTranscoder_UASTC_R8_UNORM.Name;\r\n    }\r\n\r\n    public initialize(): void {\r\n        super.initialize();\r\n        this._transcodeInPlace = false;\r\n        this.setModulePath(LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL);\r\n    }\r\n\r\n    public transcode(\r\n        src: KTX2.SourceTextureFormat,\r\n        dst: KTX2.TranscodeTarget,\r\n        level: number,\r\n        width: number,\r\n        height: number,\r\n        uncompressedByteLength: number,\r\n        ktx2Reader: KTX2FileReader,\r\n        imageDesc: IKTX2_ImageDesc | null,\r\n        encodedData: Uint8Array\r\n    ): Promise<Uint8Array | null> {\r\n        return this._loadModule().then((moduleWrapper: any) => {\r\n            const transcoder: any = moduleWrapper.module;\r\n            const [, uncompressedTextureView] = this._prepareTranscoding(width, height, uncompressedByteLength, encodedData, 1);\r\n\r\n            return transcoder.decode(width, height) === 0 ? uncompressedTextureView!.slice() : null;\r\n        });\r\n    }\r\n}\r\n","import * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport { LiteTranscoder } from \"./liteTranscoder\";\r\nimport type { KTX2FileReader, IKTX2_ImageDesc } from \"../ktx2FileReader\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class LiteTranscoder_UASTC_RG8_UNORM extends LiteTranscoder {\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder (srgb)\r\n     */\r\n    public static WasmModuleURL = \"https://preview.babylonjs.com/ktx2Transcoders/1/uastc_rg8_unorm.wasm\";\r\n\r\n    public static CanTranscode(src: KTX2.SourceTextureFormat, dst: KTX2.TranscodeTarget, isInGammaSpace: boolean): boolean {\r\n        return src === KTX2.SourceTextureFormat.UASTC4x4 && dst === KTX2.TranscodeTarget.RG8;\r\n    }\r\n\r\n    public static Name = \"UniversalTranscoder_UASTC_RG8_UNORM\";\r\n\r\n    public getName(): string {\r\n        return LiteTranscoder_UASTC_RG8_UNORM.Name;\r\n    }\r\n\r\n    public initialize(): void {\r\n        super.initialize();\r\n        this._transcodeInPlace = false;\r\n        this.setModulePath(LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL);\r\n    }\r\n\r\n    public transcode(\r\n        src: KTX2.SourceTextureFormat,\r\n        dst: KTX2.TranscodeTarget,\r\n        level: number,\r\n        width: number,\r\n        height: number,\r\n        uncompressedByteLength: number,\r\n        ktx2Reader: KTX2FileReader,\r\n        imageDesc: IKTX2_ImageDesc | null,\r\n        encodedData: Uint8Array\r\n    ): Promise<Uint8Array | null> {\r\n        return this._loadModule().then((moduleWrapper: any) => {\r\n            const transcoder: any = moduleWrapper.module;\r\n            const [, uncompressedTextureView] = this._prepareTranscoding(width, height, uncompressedByteLength, encodedData, 2);\r\n\r\n            return transcoder.decode(width, height) === 0 ? uncompressedTextureView!.slice() : null;\r\n        });\r\n    }\r\n}\r\n","import * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport { Transcoder } from \"../transcoder\";\r\nimport type { KTX2FileReader, IKTX2_ImageDesc } from \"../ktx2FileReader\";\r\nimport { WASMMemoryManager } from \"../wasmMemoryManager\";\r\n\r\ndeclare let MSC_TRANSCODER: any;\r\n\r\ndeclare function importScripts(...urls: string[]): void;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MSCTranscoder extends Transcoder {\r\n    /**\r\n     * URL to use when loading the MSC transcoder\r\n     */\r\n    public static JSModuleURL = \"https://preview.babylonjs.com/ktx2Transcoders/1/msc_basis_transcoder.js\";\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    public static WasmModuleURL = \"https://preview.babylonjs.com/ktx2Transcoders/1/msc_basis_transcoder.wasm\";\r\n\r\n    public static UseFromWorkerThread = true;\r\n\r\n    public static Name = \"MSCTranscoder\";\r\n\r\n    public getName(): string {\r\n        return MSCTranscoder.Name;\r\n    }\r\n\r\n    private _mscBasisTranscoderPromise: Promise<void>;\r\n    private _mscBasisModule: any;\r\n\r\n    private _getMSCBasisTranscoder(): Promise<void> {\r\n        if (this._mscBasisTranscoderPromise) {\r\n            return this._mscBasisTranscoderPromise;\r\n        }\r\n\r\n        this._mscBasisTranscoderPromise = WASMMemoryManager.LoadWASM(MSCTranscoder.WasmModuleURL).then((wasmBinary) => {\r\n            if (MSCTranscoder.UseFromWorkerThread) {\r\n                importScripts(MSCTranscoder.JSModuleURL);\r\n            }\r\n            // Worker Number = 0 and MSC_TRANSCODER has not been loaded yet.\r\n            else if (typeof MSC_TRANSCODER === \"undefined\") {\r\n                return new Promise((resolve, reject) => {\r\n                    const head = document.getElementsByTagName(\"head\")[0];\r\n                    const script = document.createElement(\"script\");\r\n                    script.setAttribute(\"type\", \"text/javascript\");\r\n                    script.setAttribute(\"src\", MSCTranscoder.JSModuleURL);\r\n\r\n                    script.onload = () => {\r\n                        MSC_TRANSCODER({ wasmBinary }).then((basisModule: any) => {\r\n                            basisModule.initTranscoders();\r\n                            this._mscBasisModule = basisModule;\r\n                            resolve();\r\n                        });\r\n                    };\r\n\r\n                    script.onerror = () => {\r\n                        reject(\"Can not load MSC_TRANSCODER script.\");\r\n                    };\r\n\r\n                    head.appendChild(script);\r\n                });\r\n            }\r\n\r\n            return new Promise((resolve) => {\r\n                MSC_TRANSCODER({ wasmBinary }).then((basisModule: any) => {\r\n                    basisModule.initTranscoders();\r\n                    this._mscBasisModule = basisModule;\r\n                    resolve();\r\n                });\r\n            });\r\n        });\r\n\r\n        return this._mscBasisTranscoderPromise;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static CanTranscode(src: KTX2.SourceTextureFormat, dst: KTX2.TranscodeTarget, isInGammaSpace: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    public transcode(\r\n        src: KTX2.SourceTextureFormat,\r\n        dst: KTX2.TranscodeTarget,\r\n        level: number,\r\n        width: number,\r\n        height: number,\r\n        uncompressedByteLength: number,\r\n        ktx2Reader: KTX2FileReader,\r\n        imageDesc: IKTX2_ImageDesc | null,\r\n        encodedData: Uint8Array\r\n    ): Promise<Uint8Array | null> {\r\n        const isVideo = false;\r\n\r\n        return this._getMSCBasisTranscoder().then(() => {\r\n            const basisModule = this._mscBasisModule;\r\n\r\n            let transcoder: any;\r\n            let imageInfo: any;\r\n            let result: any;\r\n            let textureData: any = null;\r\n\r\n            try {\r\n                transcoder = src === KTX2.SourceTextureFormat.UASTC4x4 ? new basisModule.UastcImageTranscoder() : new basisModule.BasisLzEtc1sImageTranscoder();\r\n                const texFormat = src === KTX2.SourceTextureFormat.UASTC4x4 ? basisModule.TextureFormat.UASTC4x4 : basisModule.TextureFormat.ETC1S;\r\n\r\n                imageInfo = new basisModule.ImageInfo(texFormat, width, height, level);\r\n\r\n                const targetFormat = basisModule.TranscodeTarget[KTX2.TranscodeTarget[dst]]; // works because the labels of the sourceTextureFormat enum are the same as the property names used in TranscodeTarget!\r\n\r\n                if (!basisModule.isFormatSupported(targetFormat, texFormat)) {\r\n                    throw new Error(\r\n                        `MSCTranscoder: Transcoding from \"${KTX2.SourceTextureFormat[src]}\" to \"${KTX2.TranscodeTarget[dst]}\" not supported by current transcoder build.`\r\n                    );\r\n                }\r\n\r\n                if (src === KTX2.SourceTextureFormat.ETC1S) {\r\n                    const sgd = ktx2Reader.supercompressionGlobalData;\r\n\r\n                    transcoder.decodePalettes(sgd.endpointCount, sgd.endpointsData, sgd.selectorCount, sgd.selectorsData);\r\n                    transcoder.decodeTables(sgd.tablesData);\r\n\r\n                    imageInfo.flags = imageDesc!.imageFlags;\r\n                    imageInfo.rgbByteOffset = 0;\r\n                    imageInfo.rgbByteLength = imageDesc!.rgbSliceByteLength;\r\n                    imageInfo.alphaByteOffset = imageDesc!.alphaSliceByteOffset > 0 ? imageDesc!.rgbSliceByteLength : 0;\r\n                    imageInfo.alphaByteLength = imageDesc!.alphaSliceByteLength;\r\n\r\n                    result = transcoder.transcodeImage(targetFormat, encodedData, imageInfo, 0, isVideo);\r\n                } else {\r\n                    imageInfo.flags = 0;\r\n                    imageInfo.rgbByteOffset = 0;\r\n                    imageInfo.rgbByteLength = uncompressedByteLength;\r\n                    imageInfo.alphaByteOffset = 0;\r\n                    imageInfo.alphaByteLength = 0;\r\n\r\n                    result = transcoder.transcodeImage(targetFormat, encodedData, imageInfo, 0, ktx2Reader.hasAlpha, isVideo);\r\n                }\r\n            } finally {\r\n                if (transcoder) {\r\n                    transcoder.delete();\r\n                }\r\n\r\n                if (imageInfo) {\r\n                    imageInfo.delete();\r\n                }\r\n\r\n                if (result && result.transcodedImage) {\r\n                    textureData = result.transcodedImage.get_typed_memory_view().slice();\r\n                    result.transcodedImage.delete();\r\n                }\r\n            }\r\n\r\n            return textureData;\r\n        });\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\n/**\r\n * From https://github.com/donmccurdy/zstddec by Don McCurdy\r\n */\r\ninterface DecoderExports {\r\n    memory: Uint8Array;\r\n\r\n    ZSTD_findDecompressedSize: (compressedPtr: number, compressedSize: number) => number;\r\n    ZSTD_decompress: (uncompressedPtr: number, uncompressedSize: number, compressedPtr: number, compressedSize: number) => number;\r\n    malloc: (ptr: number) => number;\r\n    free: (ptr: number) => void;\r\n}\r\n\r\nlet init: Promise<void>;\r\nlet instance: { exports: DecoderExports };\r\nlet heap: Uint8Array;\r\n\r\nconst IMPORT_OBJECT = {\r\n    env: {\r\n        emscripten_notify_memory_growth: function (): void {\r\n            heap = new Uint8Array(instance.exports.memory.buffer);\r\n        },\r\n    },\r\n};\r\n\r\n/**\r\n * ZSTD (Zstandard) decoder.\r\n */\r\nexport class ZSTDDecoder {\r\n    public static WasmModuleURL = \"https://preview.babylonjs.com/zstddec.wasm\";\r\n\r\n    init(): Promise<void> {\r\n        if (init) {\r\n            return init;\r\n        }\r\n\r\n        if (typeof fetch !== \"undefined\") {\r\n            // Web.\r\n\r\n            init = fetch(ZSTDDecoder.WasmModuleURL)\r\n                .then((response) => {\r\n                    if (response.ok) {\r\n                        return response.arrayBuffer();\r\n                    }\r\n                    throw new Error(`Could not fetch the wasm component for the Zstandard decompression lib: ${response.status} - ${response.statusText}`);\r\n                })\r\n                .then((arrayBuffer) => WebAssembly.instantiate(arrayBuffer, IMPORT_OBJECT))\r\n                .then(this._init);\r\n        } else {\r\n            // Node.js.\r\n\r\n            init = WebAssembly.instantiateStreaming(fetch(ZSTDDecoder.WasmModuleURL), IMPORT_OBJECT).then(this._init);\r\n        }\r\n\r\n        return init;\r\n    }\r\n\r\n    _init(result: WebAssembly.WebAssemblyInstantiatedSource): void {\r\n        instance = result.instance as unknown as { exports: DecoderExports };\r\n\r\n        IMPORT_OBJECT.env.emscripten_notify_memory_growth(); // initialize heap.\r\n    }\r\n\r\n    decode(array: Uint8Array, uncompressedSize = 0): Uint8Array {\r\n        if (!instance) {\r\n            throw new Error(`ZSTDDecoder: Await .init() before decoding.`);\r\n        }\r\n\r\n        // Write compressed data into WASM memory.\r\n        const compressedSize = array.byteLength;\r\n        const compressedPtr = instance.exports.malloc(compressedSize);\r\n        heap.set(array, compressedPtr);\r\n\r\n        // Decompress into WASM memory.\r\n        uncompressedSize = uncompressedSize || Number(instance.exports.ZSTD_findDecompressedSize(compressedPtr, compressedSize));\r\n        const uncompressedPtr = instance.exports.malloc(uncompressedSize);\r\n        const actualSize = instance.exports.ZSTD_decompress(uncompressedPtr, uncompressedSize, compressedPtr, compressedSize);\r\n\r\n        // Read decompressed data and free WASM memory.\r\n        const dec = heap.slice(uncompressedPtr, uncompressedPtr + actualSize);\r\n        instance.exports.free(compressedPtr);\r\n        instance.exports.free(uncompressedPtr);\r\n\r\n        return dec;\r\n    }\r\n}\r\n\r\n/**\r\n * BSD License\r\n *\r\n * For Zstandard software\r\n *\r\n * Copyright (c) 2016-present, Yann Collet, Facebook, Inc. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *    list of conditions and the following disclaimer.\r\n *\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n *  * Neither the name Facebook nor the names of its contributors may be used to\r\n *    endorse or promote products derived from this software without specific\r\n *    prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nconst DecisionTree: KTX2.IDecisionTree = {\r\n    ETC1S: {\r\n        option: \"forceRGBA\",\r\n        yes: {\r\n            transcodeFormat: KTX2.TranscodeTarget.RGBA32,\r\n            engineFormat: KTX2.EngineFormat.RGBA8Format,\r\n            roundToMultiple4: false,\r\n        },\r\n        no: {\r\n            cap: \"etc2\",\r\n            yes: {\r\n                alpha: true,\r\n                yes: {\r\n                    transcodeFormat: KTX2.TranscodeTarget.ETC2_RGBA,\r\n                    engineFormat: KTX2.EngineFormat.COMPRESSED_RGBA8_ETC2_EAC,\r\n                },\r\n                no: {\r\n                    transcodeFormat: KTX2.TranscodeTarget.ETC1_RGB,\r\n                    engineFormat: KTX2.EngineFormat.COMPRESSED_RGB8_ETC2,\r\n                },\r\n            },\r\n            no: {\r\n                cap: \"etc1\",\r\n                alpha: false,\r\n                yes: {\r\n                    transcodeFormat: KTX2.TranscodeTarget.ETC1_RGB,\r\n                    engineFormat: KTX2.EngineFormat.COMPRESSED_RGB_ETC1_WEBGL,\r\n                },\r\n                no: {\r\n                    cap: \"bptc\",\r\n                    yes: {\r\n                        transcodeFormat: KTX2.TranscodeTarget.BC7_RGBA,\r\n                        engineFormat: KTX2.EngineFormat.COMPRESSED_RGBA_BPTC_UNORM_EXT,\r\n                    },\r\n                    no: {\r\n                        cap: \"s3tc\",\r\n                        yes: {\r\n                            alpha: true,\r\n                            yes: {\r\n                                transcodeFormat: KTX2.TranscodeTarget.BC3_RGBA,\r\n                                engineFormat: KTX2.EngineFormat.COMPRESSED_RGBA_S3TC_DXT5_EXT,\r\n                            },\r\n                            no: {\r\n                                transcodeFormat: KTX2.TranscodeTarget.BC1_RGB,\r\n                                engineFormat: KTX2.EngineFormat.COMPRESSED_RGB_S3TC_DXT1_EXT,\r\n                            },\r\n                        },\r\n                        no: {\r\n                            cap: \"pvrtc\",\r\n                            needsPowerOfTwo: true,\r\n                            yes: {\r\n                                alpha: true,\r\n                                yes: {\r\n                                    transcodeFormat: KTX2.TranscodeTarget.PVRTC1_4_RGBA,\r\n                                    engineFormat: KTX2.EngineFormat.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\r\n                                },\r\n                                no: {\r\n                                    transcodeFormat: KTX2.TranscodeTarget.PVRTC1_4_RGB,\r\n                                    engineFormat: KTX2.EngineFormat.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,\r\n                                },\r\n                            },\r\n                            no: {\r\n                                transcodeFormat: KTX2.TranscodeTarget.RGBA32,\r\n                                engineFormat: KTX2.EngineFormat.RGBA8Format,\r\n                                roundToMultiple4: false,\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        },\r\n    },\r\n\r\n    UASTC: {\r\n        option: \"forceRGBA\",\r\n        yes: {\r\n            transcodeFormat: KTX2.TranscodeTarget.RGBA32,\r\n            engineFormat: KTX2.EngineFormat.RGBA8Format,\r\n            roundToMultiple4: false,\r\n        },\r\n        no: {\r\n            option: \"forceR8\",\r\n            yes: {\r\n                transcodeFormat: KTX2.TranscodeTarget.R8,\r\n                engineFormat: KTX2.EngineFormat.R8Format,\r\n                roundToMultiple4: false,\r\n            },\r\n            no: {\r\n                option: \"forceRG8\",\r\n                yes: {\r\n                    transcodeFormat: KTX2.TranscodeTarget.RG8,\r\n                    engineFormat: KTX2.EngineFormat.RG8Format,\r\n                    roundToMultiple4: false,\r\n                },\r\n                no: {\r\n                    cap: \"astc\",\r\n                    yes: {\r\n                        transcodeFormat: KTX2.TranscodeTarget.ASTC_4X4_RGBA,\r\n                        engineFormat: KTX2.EngineFormat.COMPRESSED_RGBA_ASTC_4X4_KHR,\r\n                    },\r\n                    no: {\r\n                        cap: \"bptc\",\r\n                        yes: {\r\n                            transcodeFormat: KTX2.TranscodeTarget.BC7_RGBA,\r\n                            engineFormat: KTX2.EngineFormat.COMPRESSED_RGBA_BPTC_UNORM_EXT,\r\n                        },\r\n                        no: {\r\n                            option: \"useRGBAIfASTCBC7NotAvailableWhenUASTC\",\r\n                            yes: {\r\n                                transcodeFormat: KTX2.TranscodeTarget.RGBA32,\r\n                                engineFormat: KTX2.EngineFormat.RGBA8Format,\r\n                                roundToMultiple4: false,\r\n                            },\r\n                            no: {\r\n                                cap: \"etc2\",\r\n                                yes: {\r\n                                    alpha: true,\r\n                                    yes: {\r\n                                        transcodeFormat: KTX2.TranscodeTarget.ETC2_RGBA,\r\n                                        engineFormat: KTX2.EngineFormat.COMPRESSED_RGBA8_ETC2_EAC,\r\n                                    },\r\n                                    no: {\r\n                                        transcodeFormat: KTX2.TranscodeTarget.ETC1_RGB,\r\n                                        engineFormat: KTX2.EngineFormat.COMPRESSED_RGB8_ETC2,\r\n                                    },\r\n                                },\r\n                                no: {\r\n                                    cap: \"etc1\",\r\n                                    yes: {\r\n                                        transcodeFormat: KTX2.TranscodeTarget.ETC1_RGB,\r\n                                        engineFormat: KTX2.EngineFormat.COMPRESSED_RGB_ETC1_WEBGL,\r\n                                    },\r\n                                    no: {\r\n                                        cap: \"s3tc\",\r\n                                        yes: {\r\n                                            alpha: true,\r\n                                            yes: {\r\n                                                transcodeFormat: KTX2.TranscodeTarget.BC3_RGBA,\r\n                                                engineFormat: KTX2.EngineFormat.COMPRESSED_RGBA_S3TC_DXT5_EXT,\r\n                                            },\r\n                                            no: {\r\n                                                transcodeFormat: KTX2.TranscodeTarget.BC1_RGB,\r\n                                                engineFormat: KTX2.EngineFormat.COMPRESSED_RGB_S3TC_DXT1_EXT,\r\n                                            },\r\n                                        },\r\n                                        no: {\r\n                                            cap: \"pvrtc\",\r\n                                            needsPowerOfTwo: true,\r\n                                            yes: {\r\n                                                alpha: true,\r\n                                                yes: {\r\n                                                    transcodeFormat: KTX2.TranscodeTarget.PVRTC1_4_RGBA,\r\n                                                    engineFormat: KTX2.EngineFormat.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\r\n                                                },\r\n                                                no: {\r\n                                                    transcodeFormat: KTX2.TranscodeTarget.PVRTC1_4_RGB,\r\n                                                    engineFormat: KTX2.EngineFormat.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,\r\n                                                },\r\n                                            },\r\n                                            no: {\r\n                                                transcodeFormat: KTX2.TranscodeTarget.RGBA32,\r\n                                                engineFormat: KTX2.EngineFormat.RGBA8Format,\r\n                                                roundToMultiple4: false,\r\n                                            },\r\n                                        },\r\n                                    },\r\n                                },\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        },\r\n    },\r\n};\r\n\r\nexport class TranscodeDecisionTree {\r\n    private static _IsLeafNode(node: KTX2.INode | KTX2.ILeaf): node is KTX2.ILeaf {\r\n        return (node as KTX2.ILeaf).engineFormat !== undefined;\r\n    }\r\n\r\n    private _textureFormat: KTX2.SourceTextureFormat;\r\n    private _hasAlpha: boolean;\r\n    private _isPowerOfTwo: boolean;\r\n    private _caps: KTX2.ICompressedFormatCapabilities;\r\n    private _options: KTX2.IKTX2DecoderOptions;\r\n    private _transcodeFormat: number;\r\n    private _engineFormat: number;\r\n    private _roundToMultiple4: boolean;\r\n\r\n    public get transcodeFormat() {\r\n        return this._transcodeFormat;\r\n    }\r\n\r\n    public get engineFormat() {\r\n        return this._engineFormat;\r\n    }\r\n\r\n    public get roundToMultiple4() {\r\n        return this._roundToMultiple4;\r\n    }\r\n\r\n    constructor(textureFormat: KTX2.SourceTextureFormat, hasAlpha: boolean, isPowerOfTwo: boolean, caps: KTX2.ICompressedFormatCapabilities, options?: KTX2.IKTX2DecoderOptions) {\r\n        this._textureFormat = textureFormat;\r\n        this._hasAlpha = hasAlpha;\r\n        this._isPowerOfTwo = isPowerOfTwo;\r\n        this._caps = caps;\r\n        this._options = options ?? {};\r\n\r\n        this.parseTree(DecisionTree);\r\n    }\r\n\r\n    public parseTree(tree: KTX2.IDecisionTree): boolean {\r\n        const node = this._textureFormat === KTX2.SourceTextureFormat.UASTC4x4 ? tree.UASTC : tree.ETC1S;\r\n        if (node) {\r\n            this._parseNode(node);\r\n        }\r\n        return node !== undefined;\r\n    }\r\n\r\n    private _parseNode(node: KTX2.INode | KTX2.ILeaf | undefined): void {\r\n        if (!node) {\r\n            return;\r\n        }\r\n\r\n        if (TranscodeDecisionTree._IsLeafNode(node)) {\r\n            this._transcodeFormat = node.transcodeFormat;\r\n            this._engineFormat = node.engineFormat;\r\n            this._roundToMultiple4 = node.roundToMultiple4 ?? true;\r\n        } else {\r\n            let condition = true;\r\n\r\n            if (node.cap !== undefined) {\r\n                condition = condition && !!this._caps[node.cap as keyof typeof this._caps];\r\n            }\r\n            if (node.option !== undefined) {\r\n                condition = condition && !!this._options[node.option as keyof typeof this._options];\r\n            }\r\n            if (node.alpha !== undefined) {\r\n                condition = condition && this._hasAlpha === node.alpha;\r\n            }\r\n            if (node.needsPowerOfTwo !== undefined) {\r\n                condition = condition && this._isPowerOfTwo === node.needsPowerOfTwo;\r\n            }\r\n            if (node.transcodeFormat !== undefined) {\r\n                if (Array.isArray(node.transcodeFormat)) {\r\n                    condition = condition && node.transcodeFormat.indexOf(this._transcodeFormat) !== -1;\r\n                } else {\r\n                    condition = condition && node.transcodeFormat === this._transcodeFormat;\r\n                }\r\n            }\r\n\r\n            this._parseNode(condition ? node.yes! : node.no!);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Resources used for the implementation:\r\n *  - 3js KTX2 loader: https://github.com/mrdoob/three.js/blob/dfb5c23ce126ec845e4aa240599915fef5375797/examples/jsm/loaders/KTX2Loader.js\r\n *  - Universal Texture Transcoders: https://github.com/KhronosGroup/Universal-Texture-Transcoders\r\n *  - KTX2 specification: http://github.khronos.org/KTX-Specification/\r\n *  - KTX2 binaries to convert files: https://github.com/KhronosGroup/KTX-Software/releases\r\n *  - KTX specification: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html\r\n *  - KTX-Software: https://github.com/KhronosGroup/KTX-Software\r\n */\r\nimport * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport type { IKTX2_ImageDesc } from \"./ktx2FileReader\";\r\nimport { KTX2FileReader, SupercompressionScheme } from \"./ktx2FileReader\";\r\nimport { TranscoderManager } from \"./transcoderManager\";\r\nimport { LiteTranscoder_UASTC_ASTC } from \"./Transcoders/liteTranscoder_UASTC_ASTC\";\r\nimport { LiteTranscoder_UASTC_BC7 } from \"./Transcoders/liteTranscoder_UASTC_BC7\";\r\nimport { LiteTranscoder_UASTC_RGBA_UNORM } from \"./Transcoders/liteTranscoder_UASTC_RGBA_UNORM\";\r\nimport { LiteTranscoder_UASTC_RGBA_SRGB } from \"./Transcoders/liteTranscoder_UASTC_RGBA_SRGB\";\r\nimport { LiteTranscoder_UASTC_R8_UNORM } from \"./Transcoders/liteTranscoder_UASTC_R8_UNORM\";\r\nimport { LiteTranscoder_UASTC_RG8_UNORM } from \"./Transcoders/liteTranscoder_UASTC_RG8_UNORM\";\r\nimport { MSCTranscoder } from \"./Transcoders/mscTranscoder\";\r\nimport { ZSTDDecoder } from \"./zstddec\";\r\nimport { TranscodeDecisionTree } from \"./transcodeDecisionTree\";\r\n\r\nconst isPowerOfTwo = (value: number) => {\r\n    return (value & (value - 1)) === 0 && value !== 0;\r\n};\r\n\r\n/**\r\n * Class for decoding KTX2 files\r\n *\r\n */\r\nexport class KTX2Decoder {\r\n    private _transcoderMgr: TranscoderManager;\r\n    private _zstdDecoder: ZSTDDecoder;\r\n\r\n    public static DefaultDecoderOptions: KTX2.IKTX2DecoderOptions = {};\r\n\r\n    constructor() {\r\n        this._transcoderMgr = new TranscoderManager();\r\n    }\r\n\r\n    public decode(data: Uint8Array, caps: KTX2.ICompressedFormatCapabilities, options?: KTX2.IKTX2DecoderOptions): Promise<KTX2.IDecodedData> {\r\n        const finalOptions = { ...options, ...KTX2Decoder.DefaultDecoderOptions };\r\n\r\n        return Promise.resolve().then(() => {\r\n            const kfr = new KTX2FileReader(data);\r\n\r\n            if (!kfr.isValid()) {\r\n                throw new Error(\"Invalid KT2 file: wrong signature\");\r\n            }\r\n\r\n            kfr.parse();\r\n\r\n            if (kfr.needZSTDDecoder) {\r\n                if (!this._zstdDecoder) {\r\n                    this._zstdDecoder = new ZSTDDecoder();\r\n                }\r\n\r\n                return this._zstdDecoder.init().then(() => {\r\n                    return this._decodeData(kfr, caps, finalOptions);\r\n                });\r\n            }\r\n\r\n            return this._decodeData(kfr, caps, finalOptions);\r\n        });\r\n    }\r\n\r\n    private _decodeData(kfr: KTX2FileReader, caps: KTX2.ICompressedFormatCapabilities, options?: KTX2.IKTX2DecoderOptions): Promise<KTX2.IDecodedData> {\r\n        const width = kfr.header.pixelWidth;\r\n        const height = kfr.header.pixelHeight;\r\n        const srcTexFormat = kfr.textureFormat;\r\n\r\n        const decisionTree = new TranscodeDecisionTree(srcTexFormat, kfr.hasAlpha, isPowerOfTwo(width) && isPowerOfTwo(height), caps, options);\r\n\r\n        if (options?.transcodeFormatDecisionTree) {\r\n            decisionTree.parseTree(options?.transcodeFormatDecisionTree);\r\n        }\r\n\r\n        const transcodeFormat = decisionTree.transcodeFormat;\r\n        const engineFormat = decisionTree.engineFormat;\r\n        const roundToMultiple4 = decisionTree.roundToMultiple4;\r\n\r\n        const transcoder = this._transcoderMgr.findTranscoder(srcTexFormat, transcodeFormat, kfr.isInGammaSpace, options?.bypassTranscoders);\r\n\r\n        if (transcoder === null) {\r\n            throw new Error(\r\n                `no transcoder found to transcode source texture format \"${KTX2.SourceTextureFormat[srcTexFormat]}\" to format \"${KTX2.TranscodeTarget[transcodeFormat]}\"`\r\n            );\r\n        }\r\n\r\n        const mipmaps: Array<KTX2.IMipmap> = [];\r\n        const dataPromises: Array<Promise<Uint8Array | null>> = [];\r\n        const decodedData: KTX2.IDecodedData = {\r\n            width: 0,\r\n            height: 0,\r\n            transcodedFormat: engineFormat,\r\n            mipmaps,\r\n            isInGammaSpace: kfr.isInGammaSpace,\r\n            hasAlpha: kfr.hasAlpha,\r\n            transcoderName: transcoder.getName(),\r\n        };\r\n\r\n        let firstImageDescIndex = 0;\r\n\r\n        for (let level = 0; level < kfr.header.levelCount; level++) {\r\n            if (level > 0) {\r\n                firstImageDescIndex += Math.max(kfr.header.layerCount, 1) * kfr.header.faceCount * Math.max(kfr.header.pixelDepth >> (level - 1), 1);\r\n            }\r\n\r\n            const levelWidth = Math.floor(width / (1 << level)) || 1;\r\n            const levelHeight = Math.floor(height / (1 << level)) || 1;\r\n\r\n            const numImagesInLevel = kfr.header.faceCount; // note that cubemap are not supported yet (see KTX2FileReader), so faceCount == 1\r\n            const levelImageByteLength = ((levelWidth + 3) >> 2) * ((levelHeight + 3) >> 2) * kfr.dfdBlock.bytesPlane[0];\r\n\r\n            const levelUncompressedByteLength = kfr.levels[level].uncompressedByteLength;\r\n\r\n            let levelDataBuffer = kfr.data.buffer;\r\n\r\n            let levelDataOffset = kfr.levels[level].byteOffset + kfr.data.byteOffset;\r\n            let imageOffsetInLevel = 0;\r\n\r\n            if (kfr.header.supercompressionScheme === SupercompressionScheme.ZStandard) {\r\n                levelDataBuffer = this._zstdDecoder.decode(new Uint8Array(levelDataBuffer, levelDataOffset, kfr.levels[level].byteLength), levelUncompressedByteLength);\r\n                levelDataOffset = 0;\r\n            }\r\n\r\n            if (level === 0) {\r\n                decodedData.width = roundToMultiple4 ? (levelWidth + 3) & ~3 : levelWidth;\r\n                decodedData.height = roundToMultiple4 ? (levelHeight + 3) & ~3 : levelHeight;\r\n            }\r\n\r\n            for (let imageIndex = 0; imageIndex < numImagesInLevel; imageIndex++) {\r\n                let encodedData: Uint8Array;\r\n                let imageDesc: IKTX2_ImageDesc | null = null;\r\n\r\n                if (kfr.header.supercompressionScheme === SupercompressionScheme.BasisLZ) {\r\n                    imageDesc = kfr.supercompressionGlobalData.imageDescs![firstImageDescIndex + imageIndex];\r\n\r\n                    encodedData = new Uint8Array(levelDataBuffer, levelDataOffset + imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength + imageDesc.alphaSliceByteLength);\r\n                } else {\r\n                    encodedData = new Uint8Array(levelDataBuffer, levelDataOffset + imageOffsetInLevel, levelImageByteLength);\r\n\r\n                    imageOffsetInLevel += levelImageByteLength;\r\n                }\r\n\r\n                const mipmap: KTX2.IMipmap = {\r\n                    data: null,\r\n                    width: levelWidth,\r\n                    height: levelHeight,\r\n                };\r\n\r\n                const transcodedData = transcoder\r\n                    .transcode(srcTexFormat, transcodeFormat, level, levelWidth, levelHeight, levelUncompressedByteLength, kfr, imageDesc, encodedData)\r\n                    .then((data) => {\r\n                        mipmap.data = data;\r\n                        return data;\r\n                    })\r\n                    .catch((reason) => {\r\n                        decodedData.errors = decodedData.errors ?? \"\";\r\n                        decodedData.errors += reason + \"\\n\" + reason.stack + \"\\n\";\r\n                        return null;\r\n                    });\r\n\r\n                dataPromises.push(transcodedData);\r\n\r\n                mipmaps.push(mipmap);\r\n            }\r\n        }\r\n\r\n        return Promise.all(dataPromises).then(() => {\r\n            return decodedData;\r\n        });\r\n    }\r\n}\r\n\r\n// Put in the order you want the transcoders to be used in priority\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_ASTC);\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_BC7);\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_RGBA_UNORM);\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_RGBA_SRGB);\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_R8_UNORM);\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_RG8_UNORM);\r\nTranscoderManager.RegisterTranscoder(MSCTranscoder); // catch all transcoder - will throw an error if the format can't be transcoded\r\n","/* eslint-disable import/no-internal-modules */\r\nimport { KTX2Decoder } from \"../index\";\r\n\r\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).KTX2DECODER = KTX2Decoder;\r\n}\r\n\r\nexport * from \"../index\";\r\n","import * as ktx2decoder from \"ktx2decoder/legacy/legacy\";\r\n\r\nexport { ktx2decoder };\r\nexport default ktx2decoder;\r\n"],"names":["root","factory","exports","module","define","amd","self","global","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","SourceTextureFormat","TranscodeTarget","EngineFormat","SupercompressionScheme","DataReader","byteOffset","_dataByteOffset","constructor","buffer","byteLength","_dataView","DataView","readUint8","getUint8","readInt8","getInt8","readUint16","getUint16","readInt16","getInt16","readUint32","getUint32","readInt32","getInt32","readUint64","combined","readUint8Array","Uint8Array","skipBytes","KTX2FileReader","data","_data","header","_header","levels","_levels","dfdBlock","_dfdBlock","supercompressionGlobalData","_supercompressionGlobalData","isValid","IsValid","parse","offsetInFile","hdrReader","vkFormat","typeSize","pixelWidth","pixelHeight","pixelDepth","layerCount","faceCount","levelCount","supercompressionScheme","dfdByteOffset","dfdByteLength","kvdByteOffset","kvdByteLength","sgdByteOffset","sgdByteLength","Error","Math","max","levelReader","push","uncompressedByteLength","dfdReader","vendorId","descriptorType","versionNumber","descriptorBlockSize","colorModel","colorPrimaries","transferFunction","flags","texelBlockDimension","x","y","z","w","bytesPlane","numSamples","samples","Array","i","sample","bitOffset","bitLength","channelType","channelFlags","samplePosition","sampleLower","sampleUpper","sgd","sgdReader","endpointCount","selectorCount","endpointsByteLength","selectorsByteLength","tablesByteLength","extendedByteLength","imageDescs","imageCount","_getImageCount","imageFlags","rgbSliceByteOffset","rgbSliceByteLength","alphaSliceByteOffset","alphaSliceByteLength","endpointsByteOffset","selectorsByteOffset","tablesByteOffset","extendedByteOffset","endpointsData","selectorsData","tablesData","extendedData","layerPixelDepth","textureFormat","hasAlpha","needZSTDDecoder","ZStandard","isInGammaSpace","static","identifier","WASMMemoryManager","path","LoadBinariesFromCurrentThread","Promise","resolve","reject","fetch","then","response","ok","arrayBuffer","status","statusText","wasmBinary","catch","reason","id","_RequestId","wasmLoadedHandler","msg","action","removeEventListener","addEventListener","postMessage","initialMemoryPages","InitialMemoryPages","_numPages","_memory","WebAssembly","Memory","initial","_memoryViewByteLength","_memoryViewOffset","_memoryView","wasmMemory","getMemoryView","numPages","offset","grow","TranscoderManager","transcoder","_Transcoders","findTranscoder","src","dst","bypass","length","CanTranscode","indexOf","Name","_getExistingTranscoder","initialize","needMemoryManager","_wasmMemoryManager","setMemoryManager","_TranscoderInstances","transcoderName","transcoders","t","getName","Transcoder","memoryMgr","transcode","level","width","height","ktx2Reader","imageDesc","encodedData","LiteTranscoder","_loadModule","_modulePromise","LoadWASM","_modulePath","instantiate","env","memory","_memoryManager","moduleWrapper","instance","memoryManager","setModulePath","modulePath","_transcodeInPlace","textureView","uncompressedTextureView","nBlocks","_prepareTranscoding","slice","uncompressedNumComponents","undefined","texMemoryPages","set","LiteTranscoder_UASTC_ASTC","super","WasmModuleURL","LiteTranscoder_UASTC_BC7","LiteTranscoder_UASTC_RGBA_UNORM","decode","LiteTranscoder_UASTC_RGBA_SRGB","LiteTranscoder_UASTC_R8_UNORM","LiteTranscoder_UASTC_RG8_UNORM","MSCTranscoder","_getMSCBasisTranscoder","_mscBasisTranscoderPromise","UseFromWorkerThread","importScripts","JSModuleURL","MSC_TRANSCODER","head","document","getElementsByTagName","script","createElement","setAttribute","onload","basisModule","initTranscoders","_mscBasisModule","onerror","appendChild","imageInfo","result","textureData","UastcImageTranscoder","BasisLzEtc1sImageTranscoder","texFormat","TextureFormat","UASTC4x4","ETC1S","ImageInfo","targetFormat","isFormatSupported","decodePalettes","decodeTables","rgbByteOffset","rgbByteLength","alphaByteOffset","alphaByteLength","transcodeImage","delete","transcodedImage","get_typed_memory_view","init","heap","IMPORT_OBJECT","emscripten_notify_memory_growth","ZSTDDecoder","_init","instantiateStreaming","array","uncompressedSize","compressedSize","compressedPtr","malloc","Number","ZSTD_findDecompressedSize","uncompressedPtr","actualSize","ZSTD_decompress","dec","free","DecisionTree","option","yes","transcodeFormat","engineFormat","roundToMultiple4","no","cap","alpha","needsPowerOfTwo","UASTC","TranscodeDecisionTree","node","_transcodeFormat","_engineFormat","_roundToMultiple4","isPowerOfTwo","caps","options","_textureFormat","_hasAlpha","_isPowerOfTwo","_caps","_options","parseTree","tree","_parseNode","_IsLeafNode","condition","isArray","KTX2Decoder","_transcoderMgr","finalOptions","DefaultDecoderOptions","kfr","_zstdDecoder","_decodeData","srcTexFormat","decisionTree","transcodeFormatDecisionTree","bypassTranscoders","mipmaps","dataPromises","decodedData","transcodedFormat","firstImageDescIndex","levelWidth","floor","levelHeight","numImagesInLevel","levelImageByteLength","levelUncompressedByteLength","levelDataBuffer","levelDataOffset","imageOffsetInLevel","imageIndex","BasisLZ","mipmap","transcodedData","errors","stack","all","RegisterTranscoder","globalObject","KTX2DECODER"],"sourceRoot":""}