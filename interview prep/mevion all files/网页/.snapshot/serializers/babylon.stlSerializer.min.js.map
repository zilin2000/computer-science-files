{"version":3,"file":"babylon.stlSerializer.min.js","mappings":"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","sources":["webpack://SERIALIZERS/webpack/universalModuleDefinition","webpack://SERIALIZERS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://SERIALIZERS/webpack/bootstrap","webpack://SERIALIZERS/webpack/runtime/define property getters","webpack://SERIALIZERS/webpack/runtime/global","webpack://SERIALIZERS/webpack/runtime/hasOwnProperty shorthand","webpack://SERIALIZERS/webpack/runtime/make namespace object","webpack://SERIALIZERS/../../../lts/serializers/generated/stl/stlSerializer.ts","webpack://SERIALIZERS/../../../lts/serializers/generated/legacy/legacy-stlSerializer.ts","webpack://SERIALIZERS/./src/stl.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-serializers\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-serializers\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"SERIALIZERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__520__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__520__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Mesh } from \"core/Meshes/mesh\";\r\nimport { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\n\r\n/**\r\n * Class for generating STL data from a Babylon scene.\r\n */\r\nexport class STLExport {\r\n    /**\r\n     * Exports the geometry of a Mesh array in .STL file format (ASCII)\r\n     * @param meshes list defines the mesh to serialize\r\n     * @param download triggers the automatic download of the file.\r\n     * @param fileName changes the downloads fileName.\r\n     * @param binary changes the STL to a binary type.\r\n     * @param isLittleEndian toggle for binary type exporter.\r\n     * @param doNotBakeTransform toggle if meshes transforms should be baked or not.\r\n     * @param supportInstancedMeshes toggle to export instanced Meshes. Enabling support for instanced meshes will override doNoBakeTransform as true\r\n     * @returns the STL as UTF8 string\r\n     */\r\n    public static CreateSTL(\r\n        meshes: (Mesh | InstancedMesh)[],\r\n        download: boolean = true,\r\n        fileName: string = \"stlmesh\",\r\n        binary: boolean = false,\r\n        isLittleEndian: boolean = true,\r\n        doNotBakeTransform: boolean = false,\r\n        supportInstancedMeshes: boolean = false\r\n    ): any {\r\n        //Binary support adapted from https://gist.github.com/paulkaplan/6d5f0ab2c7e8fdc68a61\r\n\r\n        const getFaceData = function (indices: any, vertices: any, i: number) {\r\n            const id = [indices[i] * 3, indices[i + 1] * 3, indices[i + 2] * 3];\r\n            const v = [\r\n                new Vector3(vertices[id[0]], vertices[id[0] + 2], vertices[id[0] + 1]),\r\n                new Vector3(vertices[id[1]], vertices[id[1] + 2], vertices[id[1] + 1]),\r\n                new Vector3(vertices[id[2]], vertices[id[2] + 2], vertices[id[2] + 1]),\r\n            ];\r\n            const p1p2 = v[0].subtract(v[1]);\r\n            const p3p2 = v[2].subtract(v[1]);\r\n            const n = Vector3.Cross(p3p2, p1p2).normalize();\r\n\r\n            return { v, n };\r\n        };\r\n\r\n        const writeVector = function (dataview: any, offset: number, vector: Vector3, isLittleEndian: boolean) {\r\n            offset = writeFloat(dataview, offset, vector.x, isLittleEndian);\r\n            offset = writeFloat(dataview, offset, vector.y, isLittleEndian);\r\n            return writeFloat(dataview, offset, vector.z, isLittleEndian);\r\n        };\r\n\r\n        const writeFloat = function (dataview: any, offset: number, value: number, isLittleEndian: boolean) {\r\n            dataview.setFloat32(offset, value, isLittleEndian);\r\n            return offset + 4;\r\n        };\r\n\r\n        const getVerticesData = function (mesh: InstancedMesh | Mesh) {\r\n            if (supportInstancedMeshes) {\r\n                let sourceMesh = mesh;\r\n                if (mesh instanceof InstancedMesh) {\r\n                    sourceMesh = mesh.sourceMesh;\r\n                }\r\n                const data = sourceMesh.getVerticesData(VertexBuffer.PositionKind, true, true);\r\n                if (!data) return [];\r\n                const temp = Vector3.Zero();\r\n                let index;\r\n                for (index = 0; index < data.length; index += 3) {\r\n                    Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], mesh.computeWorldMatrix(true), temp).toArray(data, index);\r\n                }\r\n                return data;\r\n            } else {\r\n                return mesh.getVerticesData(VertexBuffer.PositionKind) || [];\r\n            }\r\n        };\r\n\r\n        if (supportInstancedMeshes) {\r\n            doNotBakeTransform = true;\r\n        }\r\n\r\n        let data;\r\n\r\n        let faceCount = 0;\r\n        let offset = 0;\r\n\r\n        if (binary) {\r\n            for (let i = 0; i < meshes.length; i++) {\r\n                const mesh = meshes[i];\r\n                const indices = mesh.getIndices();\r\n                faceCount += indices ? indices.length / 3 : 0;\r\n            }\r\n\r\n            const bufferSize = 84 + 50 * faceCount;\r\n            const buffer = new ArrayBuffer(bufferSize);\r\n            data = new DataView(buffer);\r\n\r\n            offset += 80;\r\n            data.setUint32(offset, faceCount, isLittleEndian);\r\n            offset += 4;\r\n        } else {\r\n            data = \"solid stlmesh\\r\\n\";\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n            if (!doNotBakeTransform && mesh instanceof Mesh) {\r\n                mesh.bakeCurrentTransformIntoVertices();\r\n            }\r\n            const vertices = getVerticesData(mesh);\r\n            const indices = mesh.getIndices() || [];\r\n\r\n            for (let i = 0; i < indices.length; i += 3) {\r\n                const fd = getFaceData(indices, vertices, i);\r\n\r\n                if (binary) {\r\n                    offset = writeVector(data, offset, fd.n, isLittleEndian);\r\n                    offset = writeVector(data, offset, fd.v[0], isLittleEndian);\r\n                    offset = writeVector(data, offset, fd.v[1], isLittleEndian);\r\n                    offset = writeVector(data, offset, fd.v[2], isLittleEndian);\r\n                    offset += 2;\r\n                } else {\r\n                    data += \"facet normal \" + fd.n.x + \" \" + fd.n.y + \" \" + fd.n.z + \"\\r\\n\";\r\n                    data += \"\\touter loop\\r\\n\";\r\n                    data += \"\\t\\tvertex \" + fd.v[0].x + \" \" + fd.v[0].y + \" \" + fd.v[0].z + \"\\r\\n\";\r\n                    data += \"\\t\\tvertex \" + fd.v[1].x + \" \" + fd.v[1].y + \" \" + fd.v[1].z + \"\\r\\n\";\r\n                    data += \"\\t\\tvertex \" + fd.v[2].x + \" \" + fd.v[2].y + \" \" + fd.v[2].z + \"\\r\\n\";\r\n                    data += \"\\tendloop\\r\\n\";\r\n                    data += \"endfacet\\r\\n\";\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!binary) {\r\n            data += \"endsolid stlmesh\";\r\n        }\r\n\r\n        if (download) {\r\n            const a = document.createElement(\"a\");\r\n            const blob = new Blob([data], { type: \"application/octet-stream\" });\r\n            a.href = window.URL.createObjectURL(blob);\r\n            a.download = fileName + \".stl\";\r\n            a.click();\r\n        }\r\n\r\n        return data;\r\n    }\r\n}\r\n","/* eslint-disable import/no-internal-modules */\nimport * as Serializers from \"../stl/index\";\n/**\n * This is the entry point for the UMD module.\n * The entry point for a future ESM package should be index.ts\n */\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\nif (typeof globalObject !== \"undefined\") {\n    for (const serializer in Serializers) {\n        (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\n    }\n}\nexport * from \"../stl/index\";\n","import * as serializers from \"serializers/legacy/legacy-stlSerializer\";\r\nexport { serializers };\r\nexport default serializers;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__520__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","CreateSTL","meshes","download","fileName","binary","isLittleEndian","doNotBakeTransform","supportInstancedMeshes","data","getFaceData","indices","vertices","i","id","v","Vector3","p1p2","subtract","p3p2","n","normalize","writeVector","dataview","offset","vector","writeFloat","x","y","z","setFloat32","getVerticesData","mesh","sourceMesh","InstancedMesh","VertexBuffer","temp","index","length","computeWorldMatrix","toArray","faceCount","getIndices","buffer","ArrayBuffer","DataView","setUint32","Mesh","bakeCurrentTransformIntoVertices","fd","a","document","createElement","blob","Blob","type","href","URL","createObjectURL","click","globalObject","serializer","BABYLON"],"sourceRoot":""}